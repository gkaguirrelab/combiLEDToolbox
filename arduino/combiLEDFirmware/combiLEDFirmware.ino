////////////////////////////////////////////////////////////////////////////////
// Firmware for the Prizmatix CombiLED light engine
//
// This code supports the presentation of temporal modulations of the
// spectral content of light generated by the CombiLED device. The device
// contains 8, narrow-band LEDs under the control of an Arduino Uno.
//
// The "settings" vectors specify the highest and lowest intensity levels
// of each LED between 0 and 1 with 1e-4 precision. A temporal waveform
// defines a linear transition between the high and the low state,
// producing (for example) a change in luminance or L–M contrast. Gamma
// correction is performed on device, and the resulting floating value
// is cast into a 12 bit LED setting.
//
// The modulation is under the control of a waveform (e.g., sin, square) and
// a frequency [Hz]. After setup, the code enters a run loop during which each
// LED is updated sequentially. The waveform is used to define a floating
// point level (0-1), which is mapped between the low and high setting values.
//
// There is a minimum amount of time required to address an LED (about 250
// microseconds). The routine will attempt to update LEDs at this interval,
// but computational overhead results in ~700 microseconds (0.7 msecs)
// per LED update. The program clock advances and, for each cycle, determines
// where we are in the waveform and updates the settings on the next LED. As
// a consequence, different LEDs oscillate at different phase delays of the
// waveform.
//
// Timing is based upon calls to the micros() function, which returns the
// microseconds elapsed since power on for the Arduino. On a 16 MHz Arduino
// board (such as the Uno used in the CombiLED), this value has a resolution
// of 4 microseconds. The value will overflow and restart at zero after
// approximately 70 minutes. The consequence of this overflow will be a tiny
// stutter in an ongoing modulation.
//
// The basis of the clock value is the Internal RC Oscillator on the ATmega48A
// microcontroller. The timing of the RC Oscillator is factory calibrated with
// a rated calibration accuracy of ±10% (Section 29.4.1 of the megaAVR Data
// Sheet). Therefore, the code supports a multiplicative timing adjustment
// (clockAdjustFactor) that can be set in Config Mode. The timing adjustment
// may be informed using the "CT" call in Config Mode, which returns
// the output of micros(). This factor is applied to the cycleDur variables.
//
// In addition to the frequency modulation of the waveform, a superimposed
// amplitude modulation may be specified, as well as a "ramp" at modulation
// onset and offset.
//
// In operation, the firmware supports placing the device in three states:
//  RUN MODE (RM) -- continuously present the specified modulation
//  CONFIG MODE (CM) -- change the parameters of the modulation
//  DIRECT MODE (DM) -- pass setting values directly to the LEDs; this
//                      mode is used when performing device calibration.
//
// Global variables of note:
//  simulatePrizmatix   Boolean. If set to true, the code treats the Arduino
//                      built-in LED as LED0. The intensity of the LED is
//                      pulse-width modulated. The other 7 channels are ignored.
//  gammaCorrectInDirectMode  Boolean. Normally set to false. Set to true for
//                      the particular instance (e.g.) of wishing to confirm via a
//                      calibration measurement the effect of gamma correction.
//  maxLevelVal         4095. This is the max of the 12-bit range.
//  settingScale        65536. To save memory, many variables are uint16,
//                      with an expected value of 0 - 65536. The variable is
//                      divided by the setting scale to yield a float.
//  minLEDAddressTime   Scalar, microseconds. We find that it takes 234 microsecs
//                      to write a setting to one LED. We ensure that we don't
//                      try to update settings faster than this, as it causes
//                      collisions in the communication channel.
//  settingsHigh, settingsLow 8x1 int matrix, all between 0 and settingScale. Each
//                      value defines the high or low setting for each of the 8 LEDs.
//                      The specified value is divided by 65536 to yield a floaat
//                      between 0 and 1. This value is subject to gamma correction
//                      prior to being passed to the LED.
//  settingsDirect      8x1 int matrix, all between 0 and 65536. This stores the
//                      settings values when in direct mode.
//  background          8x1 int array of value 0-65536. Specifies the
//                      background level for each LED.
//  bimodalModFlag      Boolean. If set to true, the modulation is bimodal around
//                      a background. If set to false, the modulation is unimodal
//                      against the background of the low settings.
//  fmContrast          Float, between 0 and 1. Defines the contrast of the
//                      modulation relative to its maximum.
//  gammaParams         8x6 float matrix. Defines the parameters of a 5th order
//                      polynomial (plus an offset) that define the conversion
//                      of the desired intensity level to the corresponding
//                      device level for each LED. These parameters are used to
//                      create a gamma correction look-up table.
//  fmWaveformIndex     Scalar. Defines the waveform profile to be used:
//                        0 - no modulation (stay at background)
//                        1 - sinusoid
//                        2 - square wave (off-on)
//                        3 - saw-tooth on
//                        4 - saw-tooth off
//                        5 - compound modulation
//                        6 - white noise (frequency not relevant here)
//  fmCycleDurMicroSecs Scalar. The duration in microseconds of the fm waveform.
//  fmPhaseOffset       Float, 0-1. Used to shift the phase of the fm waveform.
//  amWaveformIndex     Scalar. Defines the amplitude modulation profile:
//                        0 - none
//                        1 - sinusoid modulation
//                        2 - square wave modulation
//  amCycleDurMicroSecs Scalar. The duration in microseconds of the am waveform.
//  amPhaseOffset       Float, 0-1. Used to shift the phase of the am waveform.
//  blinkDurMicroSecs   Scalar. Duration of attention event in milliseconds.
//                      During run-mode, passing a "blink" command sets all LEDs
//                      to zero for the blink duration. Default is 100 msecs.
//  ledUpdateOrder      8x1 int array, of values 0-7. Defines the order in which
//                      the LEDs are updated across the cycle. By default, the order
//                      interleaves LEDs.
//
//
//

// package to write to the LEDs
#include <Wire.h>

// Define values needed for fixed point arithmetic
#define FIXED_POINT_SHIFT 16
#define FIXED_POINT_SCALE (1UL << FIXED_POINT_SHIFT)       // This is 65536
#define FIXED_POINT_HALF (1UL << (FIXED_POINT_SHIFT - 1))  // This is 32768


////////////////////////// SIMULATE PRIZMATIX //////////////////////////////////
// Set this variable to use the built-in LED to simulate
// the output of the Prizmatix device
//
bool simulatePrizmatix = false;
////////////////////////////////////////////////////////////////////////////////


////////////////////////// DIRECT MODE BEHAVIOR ////////////////////////////////
// Direct mode is used to calibrate the device. This flag controls
// if the settings that are sent in direct mode are subjected to the
// on-board gamma correction. If the device is being calibrated, we
// generally do not want to gamma correct, as part of the purpose of
// calibration is to measure the gamma table. The primary use of this
// flag is to conduct a test to confirm that the on-board gamma
// correction yields a linear-appearing set of responses in a
// calibration measure that uses this correction.
//
bool gammaCorrectInDirectMode = false;
////////////////////////////////////////////////////////////////////////////////


// Fixed hardware values
const int maxLevelVal = 4095;       // maximum setting value for the LEDs (12 bit)
const int minLEDAddressTime = 250;  // time required to set an LED (microsecs)

// Fixed reality values
const float pi = 3.1415927;

// Fixed value that scales various interger variables between 0 and 1 using
// integer representations to save memory and execution time. We leave a little 
// headroom to avoid getting stuck on overflow errors at max values
const unsigned long settingScale = 65535;

// The resolution with which we will define various look-up tables
const int nGammaLevels = 25;
const int nFmModLevels = 100;
const int nAmModLevels = 25;
const int nRampModLevels = 25;

// The number of parameters used to define the gamma polynomial function
// (5th degree + 1)
const int nGammaParams = 6;

// Define the device states
enum { CONFIG,
       RUN,
       DIRECT } deviceState = RUN;

// Global and control variables
const uint8_t inputStringLen = 12;  // size of the command string buffer
char inputString[inputStringLen];   // a character vector to hold incoming data
uint8_t inputCharIndex = 0;         // index to count our accumulated characters
bool stringComplete = false;        // whether the input string is complete
bool modulationState = false;       // When we are running, are we modulating?

// Define settings and modulations
const uint8_t nLEDs = 8;  // the number of LEDs

// A default setting, which is bimodal, 100% Light Flux. Uint16 precision
uint16_t settingsLow[nLEDs] = { 0, 0, 0, 0, 0, 0, 0, 0 };
uint16_t settingsHigh[nLEDs] = { 65535, 65535, 65535, 65535, 65535, 65535, 65535, 65535 };
uint16_t background[nLEDs] = { 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768 };
bool bimodalModFlag = true;

// The vector of settings used in direct mode
uint16_t settingsDirect[nLEDs] = { 0, 0, 0, 0, 0, 0, 0, 0 };

// A frequency modulation look-up table.
uint16_t fmModTable[nFmModLevels];

// Controls if we attempt to perform linear interpolation between levels of the
// fm, am and ramp mod tables. The master flag (attemptToInterpolateWaveforms)
// controls if we try to do any interpolation at all. If set to true, then,
// for continuous modulations, the individual interpolation flags will be set
// to true. Generally, we leave this set to false, as we have 100 discrete levels
// to define frequency and amplitude modulations, which is plenty.
bool attemptToInterpolateWaveforms = false;
bool interpolateFmWaveform = false;
bool interpolateAmWaveform = false;
bool interpolateRampWaveform = false;

// Adjust the overall contrast of the modulation between 0 and 1
float fmContrast = 1;

// The ledUpdateOrder vector is regenerated whenever the settings or background
// changes. The idea is to skip updating LEDs if their settings never change
// from the background.
int nActiveLEDs = nLEDs;
uint8_t ledUpdateOrder[nLEDs] = { 0, 1, 2, 3, 4, 5, 6, 7 };

// A gamma table. uint16_t precision
uint16_t gammaTable[nLEDs][nGammaLevels] = {
  { 0, 2033, 4150, 6321, 8544, 10818, 13143, 15519, 17948, 20431, 22971, 25571, 28231, 30955, 33744, 36599, 39522, 42511, 45566, 48683, 51859, 55089, 58365, 61677, 65016 },
  { 0, 1271, 2643, 4143, 5769, 7519, 9395, 11395, 13521, 15772, 18149, 20653, 23286, 26049, 28944, 31971, 35134, 38432, 41869, 45445, 49162, 53021, 57024, 61170, 65462 },
  { 0, 1115, 2425, 3780, 5202, 6705, 8299, 9992, 11787, 13689, 15701, 17826, 20070, 22440, 24949, 27613, 30455, 33504, 36797, 40379, 44307, 48647, 53476, 58887, 64984 },
  { 0, 905, 1964, 3158, 4494, 5976, 7603, 9371, 11277, 13314, 15478, 17764, 20172, 22703, 25363, 28164, 31123, 34266, 37625, 41243, 45173, 49478, 54233, 59529, 65468 },
  { 0, 1195, 2677, 4429, 6396, 8531, 10800, 13174, 15634, 18165, 20759, 23414, 26130, 28911, 31762, 34691, 37706, 40812, 44017, 47324, 50732, 54239, 57834, 61505, 65230 },
  { 0, 1866, 4219, 6477, 8687, 10882, 13083, 15302, 17546, 19812, 22099, 24401, 26716, 29045, 31391, 33769, 36200, 38718, 41371, 44222, 47352, 50861, 54873, 59534, 65018 },
  { 0, 1384, 3290, 5244, 7267, 9369, 11554, 13817, 16152, 18546, 20988, 23466, 25972, 28501, 31057, 33649, 36299, 39038, 41914, 44987, 48337, 52062, 56281, 61137, 65535 },
  { 0, 1864, 4357, 6942, 9593, 12288, 15009, 17742, 20481, 23218, 25951, 28680, 31408, 34136, 36871, 39616, 42378, 45160, 47967, 50801, 53663, 56552, 59462, 62388, 65317 },
};

// The index that defines the form of any amplitude modulation
uint8_t amWaveformIndex = 0;  // Default to no amplitude modulation

// An amplitude modulation look-up table. Uint16 precision
uint16_t amModTable[nAmModLevels];

// The index that defines the form of a ramp modulation at modulation
// onset and offset
uint8_t rampWaveformIndex = 0;  // Default to no ramp modulation

// The ramp look-up table. Uint16 precision
uint16_t rampModTable[nRampModLevels];

// Variables the define compound modulations. Support is provided for a compound
// modulation composed of up to 5 sinusoids. For each sinusoid, we specify the
// harmonic index relative to the fundamental FM modulation frequency (0 for no
// modulation), the relative amplitude of that harmonic component, and the
// relative phase (in radians). Finally, we need to know the min and max values
// across a full cycle of a given compound waveform. The compoundRange
// variable holds the result. See the function "updateCompoundRange" for details.
float compoundHarmonics[5] = { 1, 2, 4, 0, 0 };         // Harmonics to include
float compoundAmps[5] = { 0.5, 1, 1, 0, 0 };            // Relative amplitudes
float compoundPhases[5] = { 0, 0.7854, 4.3633, 0, 0 };  // Phase delay in radians
float compoundRange[2] = { 0, 1 };

// Adjustment to the timing of the internal clock, used to correct for small
// factory miscalibrations of the oscillator. Values greater than 1 indicate
// that the arduino internal clock is faster than an external standard clock.
// All "dur" variables (mod, fmCycle, amCycle, ramp, blink) are multiplied by
// this factor to correct the achieved timing.
float clockAdjustFactor = 1;

// Timing variables
uint8_t fmWaveformIndex = 1;                           // Default to sinusoid
unsigned long fmCycleDurMicroSecs = round(1e6 / 3);    // 3 Hz
unsigned long amCycleDurMicroSecs = round(1e6 / 0.1);  // 0.1 Hz
unsigned long modDurMicroSecs = 0;                     // Set to zero for continuous
unsigned long blinkDurMicroSecs = round(1e6 * 0.1);    // Blink event duration in microsecs
unsigned long rampDurMicroSecs = round(1e6 * 0.5);     // Duration of a ramp modulation at
                                                       // the mod onset and offset in micro
unsigned long modulationStartTime = micros();          // Initialize these with the clock
unsigned long lastLEDUpdateTime = micros();            // Initialize these with the clock
uint8_t ledCycleIdx = 0;                               // Counter across LED updates
float fmPhaseOffset = 0;                               // 0-1; shifts the waveform phase
float amPhaseOffset = 0;                               // 0-1; shifts the waveform phase
unsigned long updateCount = 0;                         // Cycles elapsed since mod start

// Pre-computed variables
// These are pre-computed to speed execution within the primary loop
float recip_fmCycleDurMicroSecs = 1 / float(fmCycleDurMicroSecs);
float recip_amCycleDurMicroSecs = 1 / float(amCycleDurMicroSecs);
float recip_rampDurMicroSecs = 1 / float(rampDurMicroSecs);
float recip_settingScale = 1 / float(settingScale);

// setup
void setup() {
  // Initialize serial port communication
  Serial.begin(57600);
  // Modify the settings and background if we are simulating
  if (simulatePrizmatix) {
    background[0] = 0;
    for (int ii = 1; ii < nLEDs; ii++) {
      settingsHigh[ii] = 0;
      settingsLow[ii] = 0;
      background[ii] = 0;
    }
  }
  // Initialize communication with the LED(s)
  if (simulatePrizmatix) {
    // Use the built-in LED
    pinMode(LED_BUILTIN, OUTPUT);
  } else {
    // Use the wired LEDs
    Wire.begin();
    Wire.setClock(400000);
  }
  // Calculate the background settings
  updateBackgroundSettings();
  // Check which LEDs are "active"
  identifyActiveLEDs();
  // Populate the ramp modulation table
  updateRampModTable();
  // Populate the amplitude modulation table
  updateAmModTable();
  // Set the device to background
  setToBackground();
  // Update the compoundRange, in case we have
  // a compound modulation to start
  updateCompoundRange();
  // Populate the frequency modulation table
  updateFmModTable();
  // Update the "dur" variables to account for a
  // clockAdjustFactor that is different from 1
  updateDurVariables(1.0, clockAdjustFactor);
  // Show the console menu
  showModeMenu();
}

// loop
void loop() {
  // Handle inputs dependent upon the deviceState
  switch (deviceState) {
    case CONFIG:
      getConfig();
      break;
    case DIRECT:
      getDirect();
      break;
    case RUN:
      getRun();
      break;
  }
  // Advance the LED settings
  if (modulationState) {
    // Get the current time, and the time elapsed since modulation start
    unsigned long currentTime = micros();
    unsigned long elapsedTime = currentTime - modulationStartTime;
    if ((currentTime - lastLEDUpdateTime) > minLEDAddressTime) {
      // Collect diagnostic timing information
      updateCount++;
      // Determine where we are in the fm cycle
      unsigned long fmCycleTime = (elapsedTime % fmCycleDurMicroSecs);
      float fmCyclePhase = float(fmCycleTime) * recip_fmCycleDurMicroSecs;
      // Determine where we are in the am cycle if we have a non-zero amWaveformIndex
      float amCyclePhase = 0;
      if (amWaveformIndex > 0) {
        unsigned long amCycleTime = (elapsedTime % amCycleDurMicroSecs);
        amCyclePhase = float(amCycleTime) * recip_amCycleDurMicroSecs;
      }
      // Determine where we are in the ramp cycle if we have a non-zero rampWaveformIndex,
      // and a non-zero modDurMicroSecs. Default to a phase value of 1, indicating that the
      // ramp has been fully implemented
      float rampCyclePhase = 1;
      if ((rampWaveformIndex > 0) && (modDurMicroSecs > 0)) {
        // Check if we are within rampDurMicroSecs of the modulation start
        if (elapsedTime < rampDurMicroSecs) {
          rampCyclePhase = 1 - float(rampDurMicroSecs - elapsedTime) * recip_rampDurMicroSecs;
        }
        // Check if we are within rampDurMicroSecs of the modulation end
        if ((modDurMicroSecs - elapsedTime) < rampDurMicroSecs) {
          rampCyclePhase = float(modDurMicroSecs - elapsedTime) * recip_rampDurMicroSecs;
        }
      }
      // Update the lastTime
      lastLEDUpdateTime = currentTime;
      // Update the next LED
      updateLED(fmCyclePhase, amCyclePhase, rampCyclePhase, ledUpdateOrder[ledCycleIdx]);
      // Advance the ledCycleIdx
      ledCycleIdx++;
      ledCycleIdx = ledCycleIdx % nActiveLEDs;
    }
    // Check if we have exceeded the modulation duration
    if (modDurMicroSecs > 0) {
      if (elapsedTime > modDurMicroSecs) {
        modulationState = false;
        setToBackground();
      }
    }
  }
}

// Had to comment out the menu details as these serial entries
// eat up dynamic memory space.
void showModeMenu() {
  switch (deviceState) {
    case CONFIG:
      Serial.println("CM");
      break;
    case DIRECT:
      Serial.println("DM");
      break;
    case RUN:
      Serial.println("RM");
      break;
  }
}

void getConfig() {
  // Operate in modal state waiting for input
  waitForNewString();
  if (strncmp(inputString, "WF", 2) == 0) {
    // fmWaveformIndex controls the FM modulation form
    Serial.println("WF:");
    clearInputString();
    waitForNewString();
    fmWaveformIndex = atoi(inputString);
    if (fmWaveformIndex == 0) Serial.println("none");
    if (fmWaveformIndex == 1) Serial.println("sin");
    if (fmWaveformIndex == 2) Serial.println("square");
    if (fmWaveformIndex == 3) Serial.println("sawon");
    if (fmWaveformIndex == 4) Serial.println("sawoff");
    if (fmWaveformIndex == 5) {
      Serial.println("compound");
      updateCompoundRange();
    }
    if (fmWaveformIndex == 6) Serial.println("whitenoise");
    updateFmModTable();
  }
  if (strncmp(inputString, "FQ", 2) == 0) {
    // Carrier modulation frequency (float Hz)
    Serial.println("FQ:");
    clearInputString();
    waitForNewString();
    fmCycleDurMicroSecs = round(clockAdjustFactor * 1e6 / atof(inputString));
    recip_fmCycleDurMicroSecs = 1 / float(fmCycleDurMicroSecs);
    Serial.println(atof(inputString));
  }
  if (strncmp(inputString, "MD", 2) == 0) {
    // Modulation duration (float seconds)
    // Set to zero to have the modulation
    // continue until stopped
    Serial.println("MD:");
    clearInputString();
    waitForNewString();
    modDurMicroSecs = round(clockAdjustFactor * 1e6 * atof(inputString));
    Serial.println(modDurMicroSecs);
  }
  if (strncmp(inputString, "CN", 2) == 0) {
    // fmContrast (0-1 float)
    Serial.println("CN:");
    clearInputString();
    waitForNewString();
    fmContrast = atof(inputString);
    Serial.println(fmContrast);
  }
  if (strncmp(inputString, "PH", 2) == 0) {
    // fmPhaseOffset. Takes a 0-2pi float and
    // converts it to the 0-1 domain
    Serial.println("PH:");
    clearInputString();
    waitForNewString();
    fmPhaseOffset = atof(inputString) / (2 * pi);
    Serial.println(fmPhaseOffset);
  }
  if (strncmp(inputString, "RI", 2) == 0) {
    // Ramp modulation index
    Serial.println("RI:");
    clearInputString();
    waitForNewString();
    rampWaveformIndex = atoi(inputString);
    if (rampWaveformIndex == 0) Serial.println("none");
    if (rampWaveformIndex == 1) Serial.println("linear");
    if (rampWaveformIndex == 2) Serial.println("half-cosine");
    updateRampModTable();
  }
  if (strncmp(inputString, "RD", 2) == 0) {
    // Ramp duration (float seconds)
    Serial.println("RD:");
    clearInputString();
    waitForNewString();
    rampDurMicroSecs = round(clockAdjustFactor * 1e6 * atof(inputString));
    recip_rampDurMicroSecs = 1 / float(rampDurMicroSecs);
    Serial.println(rampDurMicroSecs);
  }
  if (strncmp(inputString, "AM", 2) == 0) {
    // Amplitude modulation index
    Serial.println("AM:");
    clearInputString();
    waitForNewString();
    amWaveformIndex = atoi(inputString);
    if (amWaveformIndex == 0) Serial.println("none");
    if (amWaveformIndex == 1) Serial.println("sin");
    if (amWaveformIndex == 2) Serial.println("square");
    updateAmModTable();
  }
  if (strncmp(inputString, "AF", 2) == 0) {
    // Amplitude modulation frequency
    Serial.println("AF:");
    clearInputString();
    waitForNewString();
    amCycleDurMicroSecs = round(clockAdjustFactor * 1e6 / atof(inputString));
    recip_amCycleDurMicroSecs = 1 / float(amCycleDurMicroSecs);
    Serial.println(atof(inputString));
    updateAmModTable();
  }
  if (strncmp(inputString, "AH", 2) == 0) {
    // amPhaseOffset. Takes a 0-2pi float and
    // converts it to the 0-1 domain
    Serial.println("AH:");
    clearInputString();
    waitForNewString();
    amPhaseOffset = atof(inputString) / (2 * pi);
    Serial.println(amPhaseOffset);
  }
  if (strncmp(inputString, "CH", 2) == 0) {
    // Compound modulation, 5 harmonic indices
    Serial.println("CH:");
    clearInputString();
    for (int ii = 0; ii < 5; ii++) {
      waitForNewString();
      float newVal = atof(inputString);
      compoundHarmonics[ii] = newVal;
      Serial.println(newVal);
      clearInputString();
    }
    updateCompoundRange();
    updateFmModTable();
  }
  if (strncmp(inputString, "CA", 2) == 0) {
    // Compound modulation, 5 harmonic amplitudes
    Serial.println("CA:");
    clearInputString();
    for (int ii = 0; ii < 5; ii++) {
      waitForNewString();
      float newVal = atof(inputString);
      compoundAmps[ii] = newVal;
      Serial.println(newVal);
      clearInputString();
    }
    updateCompoundRange();
    updateFmModTable();
  }
  if (strncmp(inputString, "CP", 2) == 0) {
    // Compound modulation, 5 harmonic phases
    Serial.println("CP:");
    clearInputString();
    for (int ii = 0; ii < 5; ii++) {
      waitForNewString();
      float newVal = atof(inputString);
      compoundPhases[ii] = newVal;
      Serial.println(newVal);
      clearInputString();
    }
    updateCompoundRange();
    updateFmModTable();
  }
  if (strncmp(inputString, "LU", 2) == 0) {
    // LED Update Order
    Serial.println("LP:");
    clearInputString();
    for (int ii = 0; ii < nLEDs; ii++) {
      waitForNewString();
      float newVal = atoi(inputString);
      ledUpdateOrder[ii] = newVal;
      Serial.println(newVal);
      clearInputString();
    }
  }
  if (strncmp(inputString, "ST", 2) == 0) {
    // Matrix of settings as float vals, first
    // settingsLow, then settingsHigh. These
    // are then converted to uint16 format
    Serial.println("ST:");
    clearInputString();
    float tempFloatLevel = 0;
    for (int ii = 0; ii < nLEDs; ii++) {
      waitForNewString();
      tempFloatLevel = atof(inputString);
      settingsLow[ii] = floor(tempFloatLevel * settingScale);
      Serial.println(settingsLow[ii]);
      clearInputString();
    }
    for (int ii = 0; ii < nLEDs; ii++) {
      waitForNewString();
      tempFloatLevel = atof(inputString);
      settingsHigh[ii] = floor(tempFloatLevel * settingScale);
      Serial.println(settingsHigh[ii]);
      clearInputString();
    }
    updateBackgroundSettings();
    identifyActiveLEDs();
    setToBackground();
  }
  if (strncmp(inputString, "GP", 2) == 0) {
    Serial.println("GP:");
    clearInputString();
    updateGammaTable();
    setToBackground();
  }
  if (strncmp(inputString, "UM", 2) == 0) {
    // Uni-modal modulation state
    Serial.println("UM");
    clearInputString();
    bimodalModFlag = false;
    Serial.println("unimodal mod");
    updateBackgroundSettings();
    identifyActiveLEDs();
    setToBackground();
  }
  if (strncmp(inputString, "BM", 2) == 0) {
    // Bi-modal modulation state
    Serial.println("BM");
    clearInputString();
    bimodalModFlag = true;
    Serial.println("bimodal mod");
    updateBackgroundSettings();
    identifyActiveLEDs();
    setToBackground();
  }
  if (strncmp(inputString, "BD", 2) == 0) {
    // Blink duration (int msecs)
    Serial.println("BD:");
    clearInputString();
    waitForNewString();
    blinkDurMicroSecs = round(clockAdjustFactor * 1e6 * atof(inputString));
    Serial.println(blinkDurMicroSecs);
  }
  if (strncmp(inputString, "CT", 2) == 0) {
    // Return arduino clock time in microseconds
    clearInputString();
    Serial.println(micros());
  }
  if (strncmp(inputString, "CF", 2) == 0) {
    // Pass a clock adjust factor
    Serial.println("CF:");
    clearInputString();
    waitForNewString();
    float newClockAdjustFactor = atof(inputString);
    // The modified clock adjustment is applied
    // to the set of "dur" variables
    updateDurVariables(clockAdjustFactor, newClockAdjustFactor);
    clockAdjustFactor = newClockAdjustFactor;
    Serial.println(clockAdjustFactor, 4);
  }
  if (strncmp(inputString, "RM", 2) == 0) {
    // Switch to run mode
    modulationState = false;
    deviceState = RUN;
    setToBackground();
    showModeMenu();
  }
  if (strncmp(inputString, "DM", 2) == 0) {
    // Switch to direct control mode
    modulationState = false;
    deviceState = DIRECT;
    showModeMenu();
  }
  clearInputString();
}

void getDirect() {
  // Operate in modal state waiting for input
  waitForNewString();

  // The primary Direct mode activity: send a
  // vector of settings for the LEDs.
  if (strncmp(inputString, "LL", 2) == 0) {
    Serial.println("LL:");
    clearInputString();
    float tempFloatLevel = 0;
    for (int ii = 0; ii < nLEDs; ii++) {
      waitForNewString();
      tempFloatLevel = atof(inputString);
      clearInputString();
      settingsDirect[ii] = floor(tempFloatLevel * settingScale);
      Serial.println(settingsDirect[ii]);
    }
    setToDirectSettings();
  }
  if (strncmp(inputString, "GT", 2) == 0) {
    Serial.println("GT:");
    clearInputString();
    gammaCorrectInDirectMode = true;
    Serial.println("Gamma correct in direct mode = TRUE");
    setToDirectSettings();
  }
  if (strncmp(inputString, "GF", 2) == 0) {
    Serial.println("GF:");
    clearInputString();
    gammaCorrectInDirectMode = false;
    Serial.println("Gamma correct in direct mode = FALSE");
    setToDirectSettings();
  }
  if (strncmp(inputString, "DK", 2) == 0) {
    setToOff();
    Serial.println("Lights off");
    modulationState = false;
  }
  if (strncmp(inputString, "RM", 2) == 0) {
    modulationState = false;
    deviceState = RUN;
    setToBackground();
    showModeMenu();
  }
  if (strncmp(inputString, "CM", 2) == 0) {
    modulationState = false;
    deviceState = CONFIG;
    showModeMenu();
  }
  clearInputString();
}

void getRun() {
  // Operate in amodal state; only act if we have
  // a complete string
  pollSerialPort();
  if (stringComplete) {
    stringComplete = false;
    if (strncmp(inputString, "GO", 2) == 0) {
      Serial.println("Start modulation");
      modulationState = true;
      lastLEDUpdateTime = micros();
      modulationStartTime = micros();
      updateCount = 0;
    }
    if (strncmp(inputString, "SP", 2) == 0) {
      setToBackground();
      modulationState = false;
      unsigned long currentTime = micros();
      float timePerCycle = float(currentTime - modulationStartTime) / float(updateCount);
      Serial.print("microsecs/LED update: ");
      Serial.println(timePerCycle);
    }
    if (strncmp(inputString, "BL", 2) == 0) {
      Serial.println(".");
      setToOff();
      int delayInMs = round(float(blinkDurMicroSecs) / 1e3);
      delay(delayInMs);
    }
    if (strncmp(inputString, "FQ", 2) == 0) {
      // Carrier modulation frequency (float Hz)
      fmCycleDurMicroSecs = round(clockAdjustFactor * 1e6 / atof(inputString));
      recip_fmCycleDurMicroSecs = 1 / float(fmCycleDurMicroSecs);
      Serial.println(atof(inputString + 2));
    }
    if (strncmp(inputString, "CN", 2) == 0) {
      // fmContrast (0-1 float)
      fmContrast = atof(inputString + 2);
      Serial.println(atof(inputString + 2));
    }
    if (strncmp(inputString, "BG", 2) == 0) {
      setToBackground();
      Serial.println(".");
      modulationState = false;
    }
    if (strncmp(inputString, "DK", 2) == 0) {
      setToOff();
      Serial.println(".");
      modulationState = false;
    }
    if (strncmp(inputString, "DM", 2) == 0) {
      modulationState = false;
      setToBackground();
      deviceState = DIRECT;
      showModeMenu();
    }
    if (strncmp(inputString, "CM", 2) == 0) {
      modulationState = false;
      setToBackground();
      deviceState = CONFIG;
      showModeMenu();
    }
    clearInputString();
  }
}

void updateCompoundRange() {
  // Handle compound modulations. We need
  // to scale the waveform between 0 and 1. Here we examine
  // waveform across an entire cycle and store the range to be
  // used later to scale the levels to within 0 and 1.
  if (fmWaveformIndex < 5) return;
  compoundRange[0] = 0;
  compoundRange[1] = 1;
  float newRange[2] = { 0, 0 };
  float phase = 0;
  float level = 0;
  for (int ii = 0; ii < 1000; ii++) {
    phase = float(ii) / 1000;
    level = calcFrequencyModulation(phase);
    newRange[0] = min(newRange[0], level);
    newRange[1] = max(newRange[1], level);
  }
  compoundRange[0] = newRange[0];
  compoundRange[1] = newRange[1];
}

void identifyActiveLEDs() {
  nActiveLEDs = 0;
  // Identify those LEDs that are pinned and remove them from the active list
  for (int ii = 0; ii < nLEDs; ii++) {
    if (settingsHigh[ii] != settingsLow[ii]) {
      ledUpdateOrder[nActiveLEDs] = ii;
      nActiveLEDs++;
    }
  }
}

void updateBackgroundSettings() {
  for (int ii = 0; ii < nLEDs; ii++) {
    if (bimodalModFlag) {
      background[ii] = (uint16_t)round(((unsigned long)settingsHigh[ii] + (unsigned long)settingsLow[ii]) / 2);
    } else {
      background[ii] = settingsLow[ii];
    }
  }
}

void setToDirectSettings() {
  for (int ii = 0; ii < nLEDs; ii++) {
    // Get the setting for this LED
    float floatSettingLED = float(settingsDirect[ii]) * recip_settingScale;
    // gamma correct floatSettingLED if requested
    if (gammaCorrectInDirectMode) {
      floatSettingLED = applyGammaCorrect(floatSettingLED, ii);
    }
    // Convert the floatSettingLED to a 12 bit integer
    int settingLED = round(floatSettingLED * maxLevelVal);
    if (simulatePrizmatix) {
      if (settingLED > (maxLevelVal / 2)) {
        digitalWrite(LED_BUILTIN, HIGH);
      } else {
        digitalWrite(LED_BUILTIN, LOW);
      }
    } else {
      writeToOneCombiLED(settingLED, ii);
    }
  }
}

void setToBackground() {
  for (int ii = 0; ii < nLEDs; ii++) {
    // Get the setting for this LED
    float floatSettingLED = float(background[ii]) * recip_settingScale;
    // gamma correct floatSettingLED
    floatSettingLED = applyGammaCorrect(floatSettingLED, ii);
    // Convert the floatSettingLED to a 12 bit integer
    int settingLED = round(floatSettingLED * maxLevelVal);
    if (simulatePrizmatix) {
      if (settingLED > (maxLevelVal / 2)) {
        digitalWrite(LED_BUILTIN, HIGH);
      } else {
        digitalWrite(LED_BUILTIN, LOW);
      }
    } else {
      writeToOneCombiLED(settingLED, ii);
    }
  }
}

void setToOff() {
  if (simulatePrizmatix) {
    // Use the built in Arduino LED, which has a binary state
    digitalWrite(LED_BUILTIN, LOW);
  } else {
    // Loop through the LEDs and set them to zero
    for (int ii = 0; ii < nLEDs; ii++) {
      writeToOneCombiLED(0, ii);
    }
  }
}

void updateLED(float fmCyclePhase, float amCyclePhase, float rampCyclePhase, int ledIndex) {
  // Adjust the fmCyclePhase for the fmPhaseOffset
  fmCyclePhase = phaseWrap(fmCyclePhase + fmPhaseOffset);
  // Adjust the amCyclePhase for the amPhaseOffset
  amCyclePhase = phaseWrap(amCyclePhase + amPhaseOffset);
  // Get the level for the current fmCyclePhase (0-1)
  float floatLevel = returnFrequencyModulation(fmCyclePhase);
  // If we have a bimodal modulation, then we will work with
  // levels and contrasts centered around 0 [-0.5 0.5]
  if (bimodalModFlag) {
    floatLevel = floatLevel - 0.5;
  }
  // Scale according to the fmContrast value
  floatLevel = fmContrast * floatLevel;
  // Apply any amplitude modulation
  floatLevel = returnAmplitudeModulation(amCyclePhase) * floatLevel;
  // Apply any ramp modulation
  floatLevel = returnRampModulation(rampCyclePhase) * floatLevel;
  // Calculate the LED setting differently for a unimodal or a
  // bimodal modulation
  float floatSettingLED = 0;
  if (bimodalModFlag) {
    // Get the floatSettingLED as the proportional distance between
    // the background and the low or high setting value for this
    // LED as appropriate.
    if (floatLevel < 0) {
      floatLevel = max(floatLevel, -0.5);
      floatLevel = abs(floatLevel * 2);
      floatSettingLED = (background[ledIndex] - floatLevel * (background[ledIndex] - settingsLow[ledIndex])) * recip_settingScale;
    } else {
      floatLevel = min(floatLevel, 0.5);
      floatLevel = floatLevel * 2;
      floatSettingLED = (background[ledIndex] + floatLevel * (settingsHigh[ledIndex] - background[ledIndex])) * recip_settingScale;
    }
  } else {
    // ensure that level is within the 0-1 range
    floatLevel = max(floatLevel, 0);
    floatLevel = min(floatLevel, 1);
    // Get the floatSettingLED as the proportional
    // distance between the low and high setting value for this LED
    floatSettingLED = (floatLevel * (settingsHigh[ledIndex] - settingsLow[ledIndex]) + settingsLow[ledIndex]) * recip_settingScale;
  }
  // gamma correct floatSettingLED
  floatSettingLED = applyGammaCorrect(floatSettingLED, ledIndex);
  // Convert the floatSettingLED to a 12 bit integer
  int settingLED = (int)(floatSettingLED * maxLevelVal + 0.5f);
  // Update the LED (about 230 microseconds)
  if (simulatePrizmatix) {
    pulseWidthModulate(settingLED);
  } else {
    writeToOneCombiLED(settingLED, ledIndex);
  }
}

float returnFrequencyModulation(float fmCyclePhase) {
  // Clamp input to valid range [0.0, 1.0]
  if (fmCyclePhase <= 0.0f) {
    return float(fmModTable[0]) * recip_settingScale;
  }
  if (fmCyclePhase >= 1.0f) {
    return float(fmModTable[nFmModLevels - 1]) * recip_settingScale;
  }
  // Calculate the table index using fixed-point representation (16.16 format).
  uint32_t fixedCell = (uint32_t)(fmCyclePhase * (nFmModLevels - 1) * FIXED_POINT_SCALE);
  uint16_t fixedLevel = 0;  // This will hold the result scaled by settingScale
  if (interpolateFmWaveform) {
    // --- Linear Interpolation using Integer Math ---
    // Get the integer part (index of the lower table entry)
    int lowCell = fixedCell >> FIXED_POINT_SHIFT;
    // lowCell should be <= nFmModLevels - 2 because we clamped fmCyclePhase < 1.0
    // Get the fractional part (scaled by FIXED_POINT_SCALE)
    uint32_t mantissa = fixedCell & (FIXED_POINT_SCALE - 1);
    // Get the two table values (these are scaled by settingScale)
    int val1 = fmModTable[lowCell];
    int val2 = fmModTable[lowCell + 1];
    int diff = val2 - val1;
    // Calculate the interpolated offset: (mantissa * diff) / FIXED_POINT_SCALE
    // Use int32_t for the multiplication to avoid overflow.
    int interpolated_offset = ((int32_t)mantissa * diff) >> FIXED_POINT_SHIFT;
    fixedLevel = val1 + interpolated_offset;
  } else {
    // --- Nearest-Neighbor using Integer Math ---
    // Round the fixed-point index to the nearest integer index
    // Add half the scale factor before shifting right.
    int roundedIndex = (fixedCell + FIXED_POINT_HALF) >> FIXED_POINT_SHIFT;
    // Clamp index to valid range (though rounding near edges might exceed bounds slightly)
    if (roundedIndex < 0) roundedIndex = 0;
    if (roundedIndex >= nFmModLevels) roundedIndex = nFmModLevels - 1;
    fixedLevel = fmModTable[roundedIndex];
  }
  // Return the result scaled back to the 0.0 to 1.0 range using the pre-calculated reciprocal
  return float(fixedLevel) * recip_settingScale;
}

void updateFmModTable() {
  for (int ii = 0; ii < nFmModLevels; ii++) {
    float fmCyclePhase = float(ii) / (nFmModLevels - 1);
    float modLevel = calcFrequencyModulation(fmCyclePhase);
    fmModTable[ii] = floor(modLevel * settingScale);
  }
  if (attemptToInterpolateWaveforms) {
    // Set the interpolateFmWaveform state to false unless the waveform
    // is continuous (e.g., sinusoidal)
    if ((fmWaveformIndex == 1) || (fmWaveformIndex == 5)) {
      interpolateFmWaveform = true;
    } else {
      interpolateFmWaveform = false;
    }
  } else {
    interpolateFmWaveform = false;
  }
}

float calcFrequencyModulation(float fmCyclePhase) {
  // Provides a continuous level, between 0-1, for a given waveform
  // at the specified phase position. We default to a half-on level
  // if not otherwise specified
  float level = 0.5;

  // Sinusoid
  if (fmWaveformIndex == 1) {
    level = ((sin(2 * pi * fmCyclePhase) + 1) / 2);
  }
  // Square wave, off then on
  if (fmWaveformIndex == 2) {
    if (fmCyclePhase >= 0.5) {
      level = 1;
    } else {
      level = 0;
    }
  }
  // Saw-tooth, ramping on and then sudden off
  if (fmWaveformIndex == 3) {
    level = fmCyclePhase;
  }
  // Saw-tooth, ramping off and then sudden on
  if (fmWaveformIndex == 4) {  // saw off
    level = 1 - fmCyclePhase;
  }
  // Compound sinusoidal modulation
  if (fmWaveformIndex == 5) {
    level = 0;
    for (int ii = 0; ii < 5; ii++) {
      level = level + compoundAmps[ii] * sin(compoundHarmonics[ii] * 2 * pi * fmCyclePhase - compoundPhases[ii]);
    }
    // Use the pre-computed "compoundRange" to place level in the 0-1 range
    level = (level - compoundRange[0]) / (compoundRange[1] - compoundRange[0]);
  }
  // White noise; note that the frequency and phase values are not relevant in this case
  // Need to improve this so that the set of 8 LEDs receive the same float level to avoid
  // creating a chromatic scintillation
  if (fmWaveformIndex == 6) {
    level = float(random(settingScale)) * recip_settingScale;
  }
  return level;
}


float returnAmplitudeModulation(float amCyclePhase) {
  // Clamp input to valid range [0.0, 1.0]
  if (amCyclePhase <= 0.0f) {
    // Return the first value from the table, scaled back to 0-1 range
    return float(amModTable[0]) * recip_settingScale;
  }
  if (amCyclePhase >= 1.0f) {
    // Return the last value from the table, scaled back to 0-1 range
    return float(amModTable[nAmModLevels - 1]) * recip_settingScale;
  }
  // Calculate the table index using fixed-point representation (16.16 format).
  // Multiply by (nAmModLevels - 1) for table position, then scale up.
  uint32_t fixedCell = (uint32_t)(amCyclePhase * (nAmModLevels - 1) * FIXED_POINT_SCALE);
  uint16_t fixedLevel = 0;  // This will hold the result scaled by settingScale
  if (interpolateAmWaveform) {
    // --- Linear Interpolation using Integer Math ---
    // Get the integer part (index of the lower table entry)
    int lowCell = fixedCell >> FIXED_POINT_SHIFT;
    // lowCell should be <= nAmModLevels - 2 because we clamped amCyclePhase < 1.0
    // Get the fractional part (scaled by FIXED_POINT_SCALE)
    uint32_t mantissa = fixedCell & (FIXED_POINT_SCALE - 1);
    // Get the two table values (these are scaled by settingScale)
    int val1 = amModTable[lowCell];
    int val2 = amModTable[lowCell + 1];
    int diff = val2 - val1;
    // Calculate the interpolated offset: (mantissa * diff) / FIXED_POINT_SCALE
    // Use int32_t for the multiplication to avoid overflow.
    int interpolated_offset = ((int32_t)mantissa * diff) >> FIXED_POINT_SHIFT;
    fixedLevel = val1 + interpolated_offset;
  } else {
    // --- Nearest-Neighbor using Integer Math ---
    // Round the fixed-point index to the nearest integer index
    int roundedIndex = (fixedCell + FIXED_POINT_HALF) >> FIXED_POINT_SHIFT;
    // Clamp index to valid range
    if (roundedIndex < 0) roundedIndex = 0;
    if (roundedIndex >= nAmModLevels) roundedIndex = nAmModLevels - 1;
    fixedLevel = amModTable[roundedIndex];
  }
  // Return the result scaled back to the 0.0 to 1.0 range using the pre-calculated reciprocal
  return (float)fixedLevel * recip_settingScale;
}

void updateAmModTable() {
  for (int ii = 0; ii < nAmModLevels; ii++) {
    float amCyclePhase = float(ii) / (nAmModLevels - 1);
    float modLevel = calcAmplitudeModulation(amCyclePhase);
    amModTable[ii] = floor(modLevel * settingScale);
  }
  // Set the interpolateAmWaveform state to false unless the waveform
  // is continuous (e.g., sinusoidal)
  if (attemptToInterpolateWaveforms) {
    if (amWaveformIndex == 1) {
      interpolateAmWaveform = true;
    } else {
      interpolateAmWaveform = false;
    }
  } else {
    interpolateRampWaveform = false;
  }
}

float calcAmplitudeModulation(float amCyclePhase) {
  float modLevel = 1.0;
  if (amWaveformIndex == 0) {
    // No amplitude modulation
  }
  if (amWaveformIndex == 1) {
    // Sinusoid amplitude modulation
    modLevel = (sin(2 * pi * amCyclePhase) + 1) / 2;
  }
  if (amWaveformIndex == 2) {
    // Square-wave amplitude modulation
    if (amCyclePhase >= 0.5) {
      modLevel = 1;
    } else {
      modLevel = 0;
    }
  }
  return modLevel;
}

float returnRampModulation(float rampCyclePhase) {
  // Clamp input to valid range [0.0, 1.0]
  if (rampCyclePhase <= 0.0f) {
    // Return the first value from the table, scaled back to 0-1 range
    return float(rampModTable[0]) * recip_settingScale;
  }
  if (rampCyclePhase >= 1.0f) {
    // Return the last value from the table, scaled back to 0-1 range
    return float(rampModTable[nRampModLevels - 1]) * recip_settingScale;
  }
  // Calculate the table index using fixed-point representation (16.16 format).
  // Multiply by (nRampModLevels - 1) for table position, then scale up.
  uint32_t fixedCell = (uint32_t)(rampCyclePhase * (nRampModLevels - 1) * FIXED_POINT_SCALE);
  uint16_t fixedLevel = 0;  // This will hold the result scaled by settingScale
  if (interpolateRampWaveform) {
    // --- Linear Interpolation using Integer Math ---
    // Get the integer part (index of the lower table entry)
    int lowCell = fixedCell >> FIXED_POINT_SHIFT;
    // lowCell should be <= nRampModLevels - 2 because we clamped rampCyclePhase < 1.0
    // Get the fractional part (scaled by FIXED_POINT_SCALE)
    uint32_t mantissa = fixedCell & (FIXED_POINT_SCALE - 1);
    // Get the two table values (these are scaled by settingScale)
    int val1 = rampModTable[lowCell];
    int val2 = rampModTable[lowCell + 1];
    int diff = val2 - val1;
    // Calculate the interpolated offset: (mantissa * diff) / FIXED_POINT_SCALE
    // Use int32_t for the multiplication to avoid overflow.
    int interpolated_offset = ((int32_t)mantissa * diff) >> FIXED_POINT_SHIFT;
    fixedLevel = val1 + interpolated_offset;
  } else {
    // --- Nearest-Neighbor using Integer Math ---
    // Round the fixed-point index to the nearest integer index
    int roundedIndex = (fixedCell + FIXED_POINT_HALF) >> FIXED_POINT_SHIFT;
    // Clamp index to valid range
    if (roundedIndex < 0) roundedIndex = 0;
    if (roundedIndex >= nRampModLevels) roundedIndex = nRampModLevels - 1;
    fixedLevel = rampModTable[roundedIndex];
  }
  // Return the result scaled back to the 0.0 to 1.0 range using the pre-calculated reciprocal
  return (float)fixedLevel * recip_settingScale;
}

void updateRampModTable() {
  for (int ii = 0; ii < nRampModLevels; ii++) {
    float rampCyclePhase = float(ii) / (nRampModLevels - 1);
    float modLevel = calcRampModulation(rampCyclePhase);
    rampModTable[ii] = floor(modLevel * settingScale);
  }
  // Handle waveform interpolation
  if (attemptToInterpolateWaveforms) {
    interpolateRampWaveform = true;
  } else {
    interpolateRampWaveform = false;
  }
}

float calcRampModulation(float rampCyclePhase) {
  float modLevel = 1.0;
  if (rampWaveformIndex == 0) {
    // No ramp
  }
  if (rampWaveformIndex == 1) {
    // Linear
    modLevel = rampCyclePhase;
  }
  if (rampWaveformIndex == 2) {
    // Half-cosine
    modLevel = (cos(pi + pi * rampCyclePhase) + 1) / 2;
  }
  return modLevel;
}

void updateGammaTable() {
  // Loop over the LEDs
  for (int ii = 0; ii < nLEDs; ii++) {
    // Receive a set of gammaParams that specify the
    // polynomial form of the gamma correction
    float gammaParams[nGammaParams];
    for (int kk = 0; kk < nGammaParams; kk++) {
      waitForNewString();
      gammaParams[kk] = atof(inputString);
      Serial.println(gammaParams[kk]);
      clearInputString();
    }
    // Use this set of gammaParams to populate the gammaTable
    // Note we skip the first entry as this has an obligatory
    // value of zero.
    for (int jj = 1; jj < nGammaLevels - 1; jj++) {
      float input = float(jj) / (nGammaLevels - 1);
      float corrected = 0;
      for (int kk = 0; kk < nGammaParams; kk++) {
        corrected = corrected + gammaParams[kk] * pow(input, (nGammaParams - 1) - kk);
      }
      gammaTable[ii][jj] = min(round(corrected * settingScale), settingScale);
    }
    gammaTable[ii][nGammaLevels - 1] = settingScale;
  }
}


float applyGammaCorrect(float floatSettingLED, int ledIndex) {
  // Clamp input to valid range [0.0, 1.0] - important for fixed-point calculation
  if (floatSettingLED <= 0.0f) {
    return 0.0f;  // Gamma table starts at 0
  }
  if (floatSettingLED >= 1.0f) {
    // Return the maximum value from the table, scaled back to 0-1 range
    return float(gammaTable[ledIndex][nGammaLevels - 1]) * recip_settingScale;
  }
  // Calculate the table index using fixed-point representation (16.16 format).
  // Multiply by (nGammaLevels - 1) for table position, then scale up.
  uint32_t fixedCell = (uint32_t)(floatSettingLED * (nGammaLevels - 1) * FIXED_POINT_SCALE);
  // Get the integer part (index of the lower table entry)
  int lowCell = fixedCell >> FIXED_POINT_SHIFT;
  // Get the fractional part (scaled by FIXED_POINT_SCALE)
  uint32_t mantissa = fixedCell & (FIXED_POINT_SCALE - 1);  // = fixedCell % FIXED_POINT_SCALE
  // --- Perform Linear Interpolation using Integer Math ---
  // Get the two table values (these are scaled by settingScale)
  uint16_t val1 = gammaTable[ledIndex][lowCell];
  int val2 = gammaTable[ledIndex][lowCell + 1];  // lowCell is already checked <= nGammaLevels - 2 by input clamping
  uint16_t diff = val2 - val1;
  // Calculate the interpolated offset: (mantissa * diff) / FIXED_POINT_SCALE
  // Use int32_t for the multiplication to avoid overflow.
  // The right shift performs the division by FIXED_POINT_SCALE.
  uint16_t interpolated_offset = ((int32_t)mantissa * diff) >> FIXED_POINT_SHIFT;
  // Calculate the final corrected level, still scaled by settingScale
  uint16_t fixedLevel = val1 + interpolated_offset;
  // Return the result scaled back to the 0.0 to 1.0 range using the pre-calculated reciprocal
  // Multiplication is faster than division.
  return (float)fixedLevel * recip_settingScale;
}

void updateDurVariables(float oldClockAdjustFactor, float newClockAdjustFactor) {
  fmCycleDurMicroSecs = round((float(fmCycleDurMicroSecs) / oldClockAdjustFactor) * newClockAdjustFactor);
  amCycleDurMicroSecs = round((float(amCycleDurMicroSecs) / oldClockAdjustFactor) * newClockAdjustFactor);
  modDurMicroSecs = round((float(modDurMicroSecs) / oldClockAdjustFactor) * newClockAdjustFactor);
  blinkDurMicroSecs = round((float(blinkDurMicroSecs) / oldClockAdjustFactor) * newClockAdjustFactor);
  rampDurMicroSecs = round((float(rampDurMicroSecs) / oldClockAdjustFactor) * newClockAdjustFactor);

  // Update the recip variables
  recip_fmCycleDurMicroSecs = 1 / float(fmCycleDurMicroSecs);
  recip_amCycleDurMicroSecs = 1 / float(amCycleDurMicroSecs);
  recip_rampDurMicroSecs = 1 / float(rampDurMicroSecs);
}

float phaseWrap(float phase) {
  while (phase >= 1.0f) {  // Use while in case offset makes it >= 2.0
    phase -= 1.0f;
  }
  while (phase < 0.0f) {  // Use while in case offset makes it < -1.0
    phase += 1.0f;
  }
  return phase;
}

void pulseWidthModulate(int setting) {
  // Use pulse-width modulation to vary the
  // intensity of the built in Arduino LED
  float portionOn = float(setting) / float(maxLevelVal);
  int timeOn = round(minLEDAddressTime * portionOn);
  int timeOff = minLEDAddressTime - timeOn;
  unsigned long startTime = micros();
  unsigned long currTime = micros();
  digitalWrite(LED_BUILTIN, HIGH);
  bool notDone = true;
  while (notDone) {
    currTime = micros();
    if ((currTime - startTime) > timeOn) {
      notDone = false;
    }
  }
  startTime = micros();
  digitalWrite(LED_BUILTIN, LOW);
  notDone = true;
  while (notDone) {
    currTime = micros();
    if ((currTime - startTime) > timeOff) {
      notDone = false;
    }
  }
}

// Send a setting to a wired LED
void writeToOneCombiLED(int level, int ledIndex) {
  // sanitize the input
  level = max(level, 0);
  level = min(level, maxLevelVal);
  // write the values
  Wire.beginTransmission(0x70);
  Wire.write(1 << ledIndex);
  Wire.endTransmission();
  Wire.beginTransmission(0x61);
  Wire.write(0b01011000);
  Wire.write((uint8_t)(highByte(level << 4)));
  Wire.write((uint8_t)(lowByte(level << 4)));
  Wire.endTransmission(1);
}

void pollSerialPort() {
  // Detect the case that we have received a complete string but
  // have not yet finished doing something with it. In this case,
  // do not accept anything further from the buffer
  if ((stringComplete) && (inputCharIndex == 0)) return;
  // See if there is something in the buffer
  while (Serial.available()) {
    // get the new byte:
    char inChar = (char)Serial.read();
    // add it to the inputString:
    inputString[inputCharIndex] = inChar;
    inputCharIndex++;
    if (inputCharIndex >= inputStringLen) {
      Serial.println("ERROR: Input overflow inputString buffer");
      clearInputString();
      return;
    }
    // if the incoming character is a newline,
    // set a flag so the main loop can
    // do something about it.
    if (inChar == '\n') {
      stringComplete = true;
      inputCharIndex = 0;
    }
  }
}

void waitForNewString() {
  bool stillWaiting = true;
  while (!stringComplete) {
    pollSerialPort();
  }
}

// Clean-up after receiving inputString
void clearInputString() {
  for (int ii = 0; ii < inputStringLen; ii++) {
    inputString[ii] = "";
  }
  inputCharIndex = 0;
  stringComplete = false;
}