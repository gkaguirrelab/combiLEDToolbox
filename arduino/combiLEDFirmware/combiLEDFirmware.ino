////////////////////////////////////////////////////////////////////////////////
// Firmware for the Prizmatix CombiLED light engine
//
// This code supports the presentation of temporal modulations of the
// spectral content of light generated by the CombiLED device. The device
// contains 8, narrow-band LEDs under the control of an Arduino Uno.
//
// The LEDs have the following spectroradiometric properties:
//            peak (nm)    FWHM (nm)     power (mW_)
//  LED0 --   405          14            1900
//  LED1 --   424          27            750
//  LED2 --   470          21            460
//  LED3 --   498          22            295
//  LED4 --   540          67            680
//  LED5 --   598          14            88
//  LED6 --   627          19            480
//  LED7 --   561          15            470
//
// The "settings" vectors specify the highest and lowest intensity levels
// of each LED between 0 and 1 with 1e-4 precision. A temporal waveform
// defines a linear transition between the high and the low state,
// producing (for example) a change in luminance or L–M contrast. Gamma
// correction is performed on device, and the resulting floating value
// is cast into a 12 bit LED setting.
//
// The modulation is under the control of a waveform (e.g., sin, square) and
// a frequency [Hz]. After setup, the code enters a run loop during which each
// LED is updated sequentially. The waveform is used to define a floating
// point level (0-1), which is mapped between the low and high setting values.
//
// There is a minimum amount of time required to address an LED (about 250
// microseconds). The routine will attempt to update LEDs at this interval,
// but computational overhead results in about 870 microseconds (0.87 msecs)
// per LED update. The program clock advances and, for each cycle, determines
// where we are in the waveform and updates the settings on the next LED. As
// a consequence, different LEDs oscillate at different phase delays of the
// waveform.
//
// Given 8 LEDs to update, and a maximum update rate of 0.87 msecs / LED, the
// Nyquist frequency of the device is ~140 Hz, limiting us to roughly 70 Hz as a
// max modulation frequency. We can do better than this by limiting ourselves to
// fewer than 8 active LEDs. If an LED has the same high and low setting value,
// then that LED is marked as "inactive", and skipped in the sequential
// updating. This allows the remaining, active LEDs to be updated more
// frequently.
//
// Timing is based upon calls to the micros() function, which returns the
// microseconds elapsed since power on for the Arduino. On a 16 MHz Arduino
// board (such as the Uno used in the CombiLED), this value has a resolution
// of 4 microseconds. The value will overflow and restart at zero after
// approximately 70 minutes. The basis of the clock value is the Internal RC
// Oscillator on the ATmega48A microcontroller. The timing of the RC Oscillator
// is factory calibrated with a rated calibration accuracy of ±10% (Section 29.4.1
// of the megaAVR Data Sheet). Therefore, the code supports a multiplicative timing
// adjustment (clockAdjustFactor) that can be set in Config Mode. The timing
// adjustment may be informed using the "CT" call in Config Mode, which returns
// the output of micros(). This factor is applied to the cycleDur variables.
//
// In addition to the frequency modulation of the waveform, a superimposed
// amplitude modulation may be specified.
//
// In operation, the firmware supports placing the device in three states:
//  RUN MODE (RM) -- continuously present the specified modulation
//  CONFIG MODE (CM) -- change the parameters of the modulation
//  DIRECT MODE (DM) -- pass setting values directly to the LEDs; this
//                      mode is used when performing device calibration.
//
// Global variables of note:
//  simulatePrizmatix   Boolean. If set to true, the code treats the Arduino
//                      built-in LED as LED0. The intensity of the LED is
//                      pulse-width modulated. The other 7 channels are ignored.
//  gammaCorrectInDirectMode  Boolean. Normally set to false. Set to true for
//                      the particular instance of wishing to confirm via a
//                      calibration measurement the effect of gamma correction.
//  maxLevelVal         4095. This is the max of the 12-bit range.
//  settingScale        1e4. To save memory, many variables are unsigned ints,
//                      with an expected value of 0 - 1e4. The variable is
//                      divided by the setting scale to yield a float.
//  minLEDAddressTime   Scalar, microseconds. We find that it takes 234 microsecs
//                      to write a setting to one LED. We ensure that we don't
//                      try to update settings faster than this, as it causes
//                      collisions in the communication channel.
//  settingsHigh, settingsLow 8x1 int matrix, all between 0 and 1e4. Each value
//                      defines the high or low setting for each of the 8 LEDs.
//                      The specified value is divided by 1e4 to yield a floaat
//                      between 0 and 1. This value is subject to gamma correction
//                      prior to being passed to the LED.
//  settingsDirect      8x1 int matrix, all between 0 and 1e4. This stores the
//                      settings values when in direct mode.
//  background          8x1 int array of value 0-1e4. Specifies the
//                      background level for each LED.
//  bimodalModFlag      Boolean. If set to true, the modulation is bimodal around
//                      a background. If set to false, the modulation is unimodal
//                      against the background of the low settings.
//  fmContrast          Float, between 0 and 1. Defines the contrast of the
//                      modulation relative to its maximum.
//  gammaParams         8x6 float matrix. Defines the parameters of a 5th order
//                      polynomial (plus an offset) that define the conversion
//                      of the desired intensity level to the corresponding
//                      device level for each LED. These parameters are used to
//                      create a gamma correction look-up table.
//  waveformIndex       Scalar. Defines the waveform profile to be used:
//                        0 - no modulation (stay at background)
//                        1 - sinusoid
//                        2 - square wave (off-on)
//                        3 - saw-tooth on
//                        4 - saw-tooth off
//                        5 - compound modulation
//                        6 - white noise (frequency not relevant here)
//  fmCycleDurSecs      Scalar. The duration in microseconds of the fm waveform.
//  fmPhaseOffset       Float, 0-1. Used to shift the phase of the fm waveform.
//  amplitudeIndex      Scalar. Defines the amplitude modulation profile:
//                        0 - none
//                        1 - sinusoid modulation
//                        2 - half-cosine window
//  amCycleDurSecs      Scalar. The duration in microseconds of the am waveform.
//  amPhaseOffset       Float, 0-1. Used to shift the phase of the am waveform.
//  amplitudeVals       2x1 float array. Values control the amplitude modulation,
//                      varying by the amplitudeIndex.
//  blinkDurMSecs       Scalar. Duration of attention event in milliseconds.
//                      During run-mode, passing a "blink" command sets all LEDs
//                      to zero for the blink duration. Default is 100 msecs.
//  ledUpdateOrder      8x1 int array, of values 0-7. Defines the order in which
//                      the LEDs are updated across the cycle. By default, the order
//                      interleaves LEDs.
//
//
//

// package to write to the LEDs
#include <Wire.h>


////////////////////////// SIMULATE PRIZMATIX //////////////////////////////////
// Set this variable to use the built-in LED to simulate
// the output of the Prizmatix device
//
bool simulatePrizmatix = true;
////////////////////////////////////////////////////////////////////////////////


////////////////////////// DIRECT MODE BEHAVIOR ////////////////////////////////
// Direct mode is used to calibrate the device. This flag controls
// if the settings that are sent in direct mode are subjected to the
// on-board gamma correction. If the device is being calibrated, we
// generally do not want to gamma correct, as part of the purpose of
// calibration is to measure the gamma table. The primary use of this
// flag is to conduct a test to confirm that the on-board gamma
// correction yields a linear-appearing set of responses in a
// calibration measure that uses this correction.
//
bool gammaCorrectInDirectMode = false;
////////////////////////////////////////////////////////////////////////////////


// Fixed hardware values
const int maxLevelVal = 4095;       // maximum setting value for the LEDs
const int minLEDAddressTime = 250;  // time required to set an LED (microsecs)

// Fixed reality values
const float pi = 3.1415927;

// Fixed value that scales various interger variables between 0 and 1
const int settingScale = 1e4;

// The resolution with which we will define various look-up tables
const int nGammaLevels = 25;
const int nAmModLevels = 100;
const int nFmModLevels = 100;

// The number of parameters used to define the gamma polynomial function
// (5th degree + 1)
const int nGammaParams = 6;

// Define the device states
enum { CONFIG,
       RUN,
       DIRECT } deviceState = RUN;

// Global and control variables
const uint8_t inputStringLen = 12;  // size of the command string buffer
char inputString[inputStringLen];   // a character vector to hold incoming data
uint8_t inputCharIndex = 0;         // index to count our accumulated characters
bool stringComplete = false;        // whether the input string is complete
bool modulationState = false;       // When we are running, are we modulating?

// Define settings and modulations
const uint8_t nLEDs = 8;  // the number of LEDs

// A default setting, which is bimodal, 100% Light Flux. 0-1e4 precision
int settingsLow[nLEDs] = { 0, 0, 0, 0, 0, 0, 0, 0 };
int settingsHigh[nLEDs] = { 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000 };
int background[nLEDs] = { 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000 };
bool bimodalModFlag = true;

// The vector of settings used in direct mode
int settingsDirect[nLEDs] = { 0, 0, 0, 0, 0, 0, 0, 0 };

// A frequency modulation look-up table. 0-1e4 precision
int fmModTable[nFmModLevels];

bool interpolateWaveform = true;  // Controls if we perform linear interpolation
                                  // between levels of the fmModTable. Generally,
                                  // we want to do so for continuous (e.g., sin)
                                  // modulations, but not for discontinuous
                                  // (e.g., square wave) modulations.

// Adjust the overall contrast of the modulation between 0 and 1
float fmContrast = 1;

// The ledUpdateOrder vector is regenerated whenever the settings or background
// changes. The idea is to skip updating LEDs if their settings never change
// from the background.
int nActiveLEDs = nLEDs;
uint8_t ledUpdateOrder[nLEDs] = { 0, 1, 2, 3, 4, 5, 6, 7 };

// A gamma table. 0-1e4 precision
int gammaTable[nLEDs][nGammaLevels] = {
  { 0, 329, 640, 946, 1253, 1565, 1886, 2218, 2561, 2917, 3286, 3667, 4060, 4465, 4882, 5309, 5749, 6201, 6668, 7152, 7657, 8188, 8752, 9357, 10000 },
  { 0, 98, 246, 435, 659, 915, 1198, 1506, 1836, 2186, 2557, 2947, 3357, 3786, 4237, 4708, 5201, 5718, 6258, 6822, 7410, 8023, 8660, 9319, 10000 },
  { 0, 409, 719, 982, 1215, 1436, 1655, 1883, 2125, 2388, 2672, 2981, 3314, 3671, 4053, 4461, 4894, 5356, 5851, 6383, 6962, 7599, 8307, 9105, 10000 },
  { 0, 150, 332, 540, 769, 1016, 1278, 1552, 1840, 2141, 2457, 2790, 3141, 3515, 3914, 4342, 4802, 5298, 5833, 6411, 7034, 7704, 8423, 9192, 10000 },
  { 0, 210, 453, 723, 1017, 1331, 1664, 2012, 2375, 2750, 3138, 3536, 3946, 4366, 4798, 5242, 5698, 6169, 6655, 7157, 7678, 8220, 8784, 9373, 10000 },
  { 0, 221, 495, 800, 1128, 1473, 1829, 2190, 2555, 2921, 3287, 3654, 4022, 4395, 4773, 5162, 5566, 5989, 6437, 6917, 7434, 7996, 8609, 9281, 10000 },
  { 0, 316, 634, 957, 1284, 1617, 1956, 2300, 2650, 3005, 3366, 3733, 4105, 4485, 4872, 5270, 5679, 6103, 6546, 7013, 7508, 8039, 8614, 9240, 10000 },
  { 0, 312, 675, 1065, 1473, 1892, 2315, 2738, 3161, 3580, 3996, 4410, 4822, 5235, 5650, 6069, 6493, 6923, 7360, 7803, 8251, 8701, 9147, 9585, 10000 },
};

// Variables that define an amplitude modulation
uint8_t amplitudeIndex = 0;  // Default to no amplitude modulation
float amplitudeVals[3][2] = {
  { 0.0, 0.0 },  // no amplitude modulation;  0) unusued; 1) unusued
  { 0.0, 0.0 },  // sinusoidal modulation; 0) unusued; 1) unusued
  { 0.5, 0.0 },  // half-cosine window: 0) window duration seconds; 1) unusued
};

// An amplitude modulation look-up table. 0-1e4 precision
int amModTable[nAmModLevels];

// Variables the define compound modulations. Support is provided for a compound
// modulation composed of up to 5 sinusoids. For each sinusoid, we specify the
// harmonic index relative to the fundamental FM modulation frequency (0 for no
// modulation), the relative amplitude of that harmonic component, and the
// relative phase (in radians). Finally, we need to know the min and max values
// across a full cycle of a given compound waveform. The compoundRange
// variable holds the result. See the function "updateCompoundRange" for details.
float compoundHarmonics[5] = { 1, 2, 4, 0, 0 };         // Harmonics to include
float compoundAmps[5] = { 0.5, 1, 1, 0, 0 };            // Relative amplitudes
float compoundPhases[5] = { 0, 0.7854, 4.3633, 0, 0 };  // Phase delay in radians
float compoundRange[2] = { 0, 1 };

// Adjustment to the timing of the internal clock, used to correct for small
// factory miscalibrations of the oscillator. Values greater than 1 indicate
// that the arduino internal clock is faster than an external standard clock.
// All "dur" variables (mod, fmCycle, amCycle, ramp, blink) are multiplied by
// this factor to correct the achieved timing.
float clockAdjustFactor = 1;

// Timing variables
uint8_t waveformIndex = 1;                        // Default to sinusoid
unsigned long fmCycleDurSecs = round(1e6 / 3);    // 3 Hz
unsigned long amCycleDurSecs = round(1e6 / 0.1);  // 0.1 Hz
float modDurSecs = 0;                             // Set to 0 for continuous
int blinkDurMSecs = 100;                          // Blink event duration in msecs
int rampDurMSecs = 500;                           // Dur of half-cosine ramp at mod
                                                  // onset and offset in msecs
unsigned long modulationStartTime = micros();     // Initialize these with the clock
unsigned long lastLEDUpdateTime = micros();       // Initialize these with the clock
uint8_t ledCycleIdx = 0;                          // Counter across LED updates
float fmPhaseOffset = 0;                          // 0-1; shifts the waveform phase
float amPhaseOffset = 0;                          // 0-1; shifts the waveform phase
unsigned long updateCount = 0;                    // Cycles elapsed since mod start

// setup
void setup() {
  // Initialize serial port communication
  Serial.begin(57600);
  // Modify the settings and background if we are simulating
  if (simulatePrizmatix) {
    background[0] = 0;
    for (int ii = 1; ii < nLEDs; ii++) {
      settingsHigh[ii] = 0;
      settingsLow[ii] = 0;
      background[ii] = 0;
    }
  }
  // Initialize communication with the LED(s)
  if (simulatePrizmatix) {
    // Use the built-in LED
    pinMode(LED_BUILTIN, OUTPUT);
  } else {
    // Use the wired LEDs
    Wire.begin();
    Wire.setClock(400000);
  }
  // Calculate the background settings
  updateBackgroundSettings();
  // Check which LEDs are "active"
  identifyActiveLEDs();
  // Populate the amplitude modulation table
  updateAmModTable();
  // Set the device to background
  setToBackground();
  // Update the compoundRange, in case we have
  // a compound modulation to start
  updateCompoundRange();
  // Populate the frequency modulation table
  updateFmModTable();
  // Update the "dur" variables to account for a
  // clockAdjustFactor that is different from 1
  updateDurVariables(1.0, clockAdjustFactor);
  // Show the console menu
  showModeMenu();
}

// loop
void loop() {
  // Handle inputs dependent upon the deviceState
  switch (deviceState) {
    case CONFIG:
      getConfig();
      break;
    case DIRECT:
      getDirect();
      break;
    case RUN:
      getRun();
      break;
  }
  // Advance the LED settings
  if (modulationState) {
    unsigned long currentTime = micros();
    if ((currentTime - lastLEDUpdateTime) > minLEDAddressTime) {
      // Collect diagnostic timing information
      updateCount++;
      // Determine where we are in the fm cycle
      unsigned long fmCycleTime = ((currentTime - modulationStartTime) % fmCycleDurSecs);
      float fmCyclePhase = float(fmCycleTime) / float(fmCycleDurSecs);
      // Determine where we are in the am cycle
      unsigned long amCycleTime = ((currentTime - modulationStartTime) % amCycleDurSecs);
      float amCyclePhase = float(amCycleTime) / float(amCycleDurSecs);
      // Update the lastTime
      lastLEDUpdateTime = currentTime;
      // Update the next LED
      updateLED(fmCyclePhase, amCyclePhase, ledUpdateOrder[ledCycleIdx]);
      // Advance the ledCycleIdx
      ledCycleIdx++;
      ledCycleIdx = ledCycleIdx % nActiveLEDs;
    }
    // Check if we have exceeded the modulation duration
    if (modDurSecs > 0) {
      float elapsedTimeSecs = (currentTime - modulationStartTime) / 1e6;
      if (elapsedTimeSecs > modDurSecs) {
        modulationState = false;
        setToBackground();
      }
    }
  }
}

// Had to comment out the menu details as these serial entries
// eat up dynamic memory space.
void showModeMenu() {
  switch (deviceState) {
    case CONFIG:
      Serial.println("CM");
      break;
    case DIRECT:
      Serial.println("DM");
      break;
    case RUN:
      Serial.println("RM");
      break;
  }
}

void getConfig() {
  // Operate in modal state waiting for input
  waitForNewString();
  if (strncmp(inputString, "WF", 2) == 0) {
    // waveformIndex controls the FM modulation form
    Serial.println("WF:");
    clearInputString();
    waitForNewString();
    waveformIndex = atoi(inputString);
    if (waveformIndex == 0) Serial.println("none");
    if (waveformIndex == 1) Serial.println("sin");
    if (waveformIndex == 2) Serial.println("square");
    if (waveformIndex == 3) Serial.println("sawon");
    if (waveformIndex == 4) Serial.println("sawoff");
    if (waveformIndex == 5) {
      Serial.println("compound");
      updateCompoundRange();
    }
    if (waveformIndex == 6) Serial.println("whitenoise");
    updateFmModTable();
  }
  if (strncmp(inputString, "FQ", 2) == 0) {
    // Carrier modulation frequency (float Hz)
    Serial.println("FQ:");
    clearInputString();
    waitForNewString();
    fmCycleDurSecs = clockAdjustFactor * 1e6 / atof(inputString);
    Serial.println(atof(inputString));
  }
  if (strncmp(inputString, "MD", 2) == 0) {
    // Modulation duration (float seconds)
    // Set to zero to have the modulation
    // continue until stopped
    Serial.println("MD:");
    clearInputString();
    waitForNewString();
    modDurSecs = clockAdjustFactor * atof(inputString);
    Serial.println(modDurSecs);
  }
  if (strncmp(inputString, "CN", 2) == 0) {
    // fmContrast (0-1 float)
    Serial.println("CN:");
    clearInputString();
    waitForNewString();
    fmContrast = atof(inputString);
    Serial.println(fmContrast);
  }
  if (strncmp(inputString, "PH", 2) == 0) {
    // fmPhaseOffset. Takes a 0-2pi float and
    // converts it to the 0-1 domain
    Serial.println("PH:");
    clearInputString();
    waitForNewString();
    fmPhaseOffset = atof(inputString) / (2 * pi);
    Serial.println(fmPhaseOffset);
  }
  if (strncmp(inputString, "AM", 2) == 0) {
    // Amplitude modulation index
    Serial.println("AM:");
    clearInputString();
    waitForNewString();
    amplitudeIndex = atoi(inputString);
    if (amplitudeIndex == 0) Serial.println("none");
    if (amplitudeIndex == 1) Serial.println("sin");
    if (amplitudeIndex == 2) Serial.println("half-cos");
    updateAmModTable();
  }
  if (strncmp(inputString, "AF", 2) == 0) {
    // Amplitude modulation frequency
    Serial.println("AF:");
    clearInputString();
    waitForNewString();
    amCycleDurSecs = clockAdjustFactor * 1e6 / atof(inputString);
    Serial.println(atof(inputString));
    updateAmModTable();
  }
  if (strncmp(inputString, "AH", 2) == 0) {
    // amPhaseOffset. Takes a 0-2pi float and
    // converts it to the 0-1 domain
    Serial.println("AH:");
    clearInputString();
    waitForNewString();
    amPhaseOffset = atof(inputString) / (2 * pi);
    Serial.println(amPhaseOffset);
  }
  if (strncmp(inputString, "AV", 2) == 0) {
    // Amplitude modulation values for the current index
    Serial.println("AV:");
    clearInputString();
    waitForNewString();
    float newVal = atof(inputString);
    amplitudeVals[amplitudeIndex][0] = newVal;
    Serial.println(newVal);
    clearInputString();
    waitForNewString();
    newVal = atof(inputString);
    amplitudeVals[amplitudeIndex][1] = newVal;
    Serial.println(newVal);
    updateAmModTable();
  }
  if (strncmp(inputString, "CH", 2) == 0) {
    // Compound modulation, 5 harmonic indices
    Serial.println("CH:");
    clearInputString();
    for (int ii = 0; ii < 5; ii++) {
      waitForNewString();
      float newVal = atof(inputString);
      compoundHarmonics[ii] = newVal;
      Serial.println(newVal);
      clearInputString();
    }
    updateCompoundRange();
    updateFmModTable();
  }
  if (strncmp(inputString, "CA", 2) == 0) {
    // Compound modulation, 5 harmonic amplitudes
    Serial.println("CA:");
    clearInputString();
    for (int ii = 0; ii < 5; ii++) {
      waitForNewString();
      float newVal = atof(inputString);
      compoundAmps[ii] = newVal;
      Serial.println(newVal);
      clearInputString();
    }
    updateCompoundRange();
    updateFmModTable();
  }
  if (strncmp(inputString, "CP", 2) == 0) {
    // Compound modulation, 5 harmonic phases
    Serial.println("CP:");
    clearInputString();
    for (int ii = 0; ii < 5; ii++) {
      waitForNewString();
      float newVal = atof(inputString);
      compoundPhases[ii] = newVal;
      Serial.println(newVal);
      clearInputString();
    }
    updateCompoundRange();
    updateFmModTable();
  }
  if (strncmp(inputString, "LU", 2) == 0) {
    // LED Update Order
    Serial.println("LP:");
    clearInputString();
    for (int ii = 0; ii < nLEDs; ii++) {
      waitForNewString();
      float newVal = atoi(inputString);
      ledUpdateOrder[ii] = newVal;
      Serial.println(newVal);
      clearInputString();
    }
  }
  if (strncmp(inputString, "ST", 2) == 0) {
    // Matrix of settings int, 0-1e4, first
    // settingsLow, then settingsHigh
    Serial.println("ST:");
    clearInputString();
    for (int ii = 0; ii < nLEDs; ii++) {
      waitForNewString();
      int level = atoi(inputString);
      settingsLow[ii] = level;
      Serial.println(level);
      clearInputString();
    }
    for (int ii = 0; ii < nLEDs; ii++) {
      waitForNewString();
      int level = atoi(inputString);
      settingsHigh[ii] = level;
      Serial.println(level);
      clearInputString();
    }
    updateBackgroundSettings();
    identifyActiveLEDs();
    setToBackground();
  }
  if (strncmp(inputString, "GP", 2) == 0) {
    Serial.println("GP:");
    clearInputString();
    updateGammaTable();
    setToBackground();
  }
  if (strncmp(inputString, "UM", 2) == 0) {
    // Uni-modal modulation state
    Serial.println("UM");
    clearInputString();
    bimodalModFlag = false;
    Serial.println("unimodal mod");
    updateBackgroundSettings();
    identifyActiveLEDs();
    setToBackground();
  }
  if (strncmp(inputString, "BM", 2) == 0) {
    // Bi-modal modulation state
    Serial.println("BM");
    clearInputString();
    bimodalModFlag = true;
    Serial.println("bimodal mod");
    updateBackgroundSettings();
    identifyActiveLEDs();
    setToBackground();
  }
  if (strncmp(inputString, "BD", 2) == 0) {
    // Blink duration (int msecs)
    Serial.println("BD:");
    clearInputString();
    waitForNewString();
    blinkDurMSecs = round(clockAdjustFactor * float(atoi(inputString)));
    Serial.println(blinkDurMSecs);
  }
  if (strncmp(inputString, "IW", 2) == 0) {
    // Interpolate weights
    Serial.println("IW:");
    clearInputString();
    waitForNewString();
    interpolateWaveform = atoi(inputString);
    Serial.println(interpolateWaveform);
  }
  if (strncmp(inputString, "CT", 2) == 0) {
    // Return arduino clock time in microseconds
    clearInputString();
    Serial.println(micros());
  }
  if (strncmp(inputString, "CF", 2) == 0) {
    // Pass a clock adjust factor
    Serial.println("CF:");
    clearInputString();
    waitForNewString();
    float newClockAdjustFactor = atof(inputString);
    // The modified clock adjustment is applied
    // to the set of "dur" variables
    updateDurVariables(clockAdjustFactor,newClockAdjustFactor);
    clockAdjustFactor = newClockAdjustFactor;
    Serial.println(clockAdjustFactor,4);
  }
  if (strncmp(inputString, "RM", 2) == 0) {
    // Switch to run mode
    modulationState = false;
    deviceState = RUN;
    setToBackground();
    showModeMenu();
  }
  if (strncmp(inputString, "DM", 2) == 0) {
    // Switch to direct control mode
    modulationState = false;
    deviceState = DIRECT;
    showModeMenu();
  }
  clearInputString();
}

void getDirect() {
  // Operate in modal state waiting for input
  waitForNewString();

  // The primary Direct mode activity: send a
  // vector of settings for the LEDs.
  if (strncmp(inputString, "LL", 2) == 0) {
    Serial.println("LL:");
    clearInputString();
    for (int ii = 0; ii < nLEDs; ii++) {
      waitForNewString();
      int level = atoi(inputString);
      Serial.println(level);
      clearInputString();
      settingsDirect[ii] = level;
    }
    setToDirectSettings();
  }
  if (strncmp(inputString, "GT", 2) == 0) {
    Serial.println("GT:");
    clearInputString();
    gammaCorrectInDirectMode = true;
    Serial.println("Gamma correct in direct mode = TRUE");
    setToDirectSettings();
  }
  if (strncmp(inputString, "GF", 2) == 0) {
    Serial.println("GF:");
    clearInputString();
    gammaCorrectInDirectMode = false;
    Serial.println("Gamma correct in direct mode = FALSE");
    setToDirectSettings();
  }
  if (strncmp(inputString, "DK", 2) == 0) {
    setToOff();
    Serial.println("Lights off");
    modulationState = false;
  }
  if (strncmp(inputString, "RM", 2) == 0) {
    modulationState = false;
    deviceState = RUN;
    setToBackground();
    showModeMenu();
  }
  if (strncmp(inputString, "CM", 2) == 0) {
    modulationState = false;
    deviceState = CONFIG;
    showModeMenu();
  }
  clearInputString();
}

void getRun() {
  // Operate in amodal state; only act if we have
  // a complete string
  pollSerialPort();
  if (stringComplete) {
    stringComplete = false;
    if (strncmp(inputString, "GO", 2) == 0) {
      Serial.println("Start modulation");
      modulationState = true;
      lastLEDUpdateTime = micros();
      modulationStartTime = micros();
      updateCount = 0;
    }
    if (strncmp(inputString, "SP", 2) == 0) {
      setToBackground();
      modulationState = false;
      unsigned long currentTime = micros();
      float timePerCycle = float(currentTime - modulationStartTime) / float(updateCount);
      Serial.print("microsecs/LED update: ");
      Serial.println(timePerCycle);
    }
    if (strncmp(inputString, "BL", 2) == 0) {
      Serial.println(".");
      setToOff();
      delay(blinkDurMSecs);
    }
    if (strncmp(inputString, "FQ", 2) == 0) {
      // Carrier modulation frequency (float Hz)
      fmCycleDurSecs = clockAdjustFactor * 1e6 / atof(inputString + 2);
      Serial.println(atof(inputString + 2));
    }
    if (strncmp(inputString, "CN", 2) == 0) {
      // fmContrast (0-1 float)
      fmContrast = atof(inputString + 2);
      Serial.println(atof(inputString + 2));
    }
    if (strncmp(inputString, "BG", 2) == 0) {
      setToBackground();
      Serial.println(".");
      modulationState = false;
    }
    if (strncmp(inputString, "DK", 2) == 0) {
      setToOff();
      Serial.println(".");
      modulationState = false;
    }
    if (strncmp(inputString, "DM", 2) == 0) {
      modulationState = false;
      setToBackground();
      deviceState = DIRECT;
      showModeMenu();
    }
    if (strncmp(inputString, "CM", 2) == 0) {
      modulationState = false;
      setToBackground();
      deviceState = CONFIG;
      showModeMenu();
    }
    clearInputString();
  }
}

void updateCompoundRange() {
  // Handle compound modulations. We need
  // to scale the waveform between 0 and 1. Here we examine
  // waveform across an entire cycle and store the range to be
  // used later to scale the levels to within 0 and 1.
  if (waveformIndex < 5) return;
  compoundRange[0] = 0;
  compoundRange[1] = 1;
  float newRange[2] = { 0, 0 };
  float phase = 0;
  float level = 0;
  for (int ii = 0; ii < 1000; ii++) {
    phase = float(ii) / 1000;
    level = calcFrequencyModulation(phase);
    newRange[0] = min(newRange[0], level);
    newRange[1] = max(newRange[1], level);
  }
  compoundRange[0] = newRange[0];
  compoundRange[1] = newRange[1];
}

void identifyActiveLEDs() {
  nActiveLEDs = 0;
  // Identify those LEDs that are pinned and remove them from the active list
  for (int ii = 0; ii < nLEDs; ii++) {
    if (settingsHigh[ii] != settingsLow[ii]) {
      ledUpdateOrder[nActiveLEDs] = ii;
      nActiveLEDs++;
    }
  }
}

void updateBackgroundSettings() {
  for (int ii = 0; ii < nLEDs; ii++) {
    if (bimodalModFlag) {
      background[ii] = round((settingsHigh[ii] + settingsLow[ii]) / 2);
    } else {
      background[ii] = settingsLow[ii];
    }
  }
}

void setToDirectSettings() {
  for (int ii = 0; ii < nLEDs; ii++) {
    // Get the setting for this LED
    float floatSettingLED = float(settingsDirect[ii]) / float(settingScale);
    // gamma correct floatSettingLED if requested
    if (gammaCorrectInDirectMode) {
      floatSettingLED = applyGammaCorrect(floatSettingLED, ii);
    }
    // Convert the floatSettingLED to a 12 bit integer
    int settingLED = round(floatSettingLED * maxLevelVal);
    if (simulatePrizmatix) {
      if (settingLED > (maxLevelVal / 2)) {
        digitalWrite(LED_BUILTIN, HIGH);
      } else {
        digitalWrite(LED_BUILTIN, LOW);
      }
    } else {
      writeToOneCombiLED(settingLED, ii);
    }
  }
}

void setToBackground() {
  for (int ii = 0; ii < nLEDs; ii++) {
    // Get the setting for this LED
    float floatSettingLED = float(background[ii]) / float(settingScale);
    // gamma correct floatSettingLED
    floatSettingLED = applyGammaCorrect(floatSettingLED, ii);
    // Convert the floatSettingLED to a 12 bit integer
    int settingLED = round(floatSettingLED * maxLevelVal);
    if (simulatePrizmatix) {
      if (settingLED > (maxLevelVal / 2)) {
        digitalWrite(LED_BUILTIN, HIGH);
      } else {
        digitalWrite(LED_BUILTIN, LOW);
      }
    } else {
      writeToOneCombiLED(settingLED, ii);
    }
  }
}

void setToOff() {
  if (simulatePrizmatix) {
    // Use the built in Arduino LED, which has a binary state
    digitalWrite(LED_BUILTIN, LOW);
  } else {
    // Loop through the LEDs and set them to zero
    for (int ii = 0; ii < nLEDs; ii++) {
      writeToOneCombiLED(0, ii);
    }
  }
}

void updateLED(float fmCyclePhase, float amCyclePhase, int ledIndex) {
  // Adjust the fmCyclePhase for the fmPhaseOffset
  fmCyclePhase = fmCyclePhase + fmPhaseOffset;
  fmCyclePhase = fmCyclePhase - floor(fmCyclePhase);
  // Adjust the amCyclePhase for the amPhaseOffset
  amCyclePhase = amCyclePhase + amPhaseOffset;
  amCyclePhase = amCyclePhase - floor(amCyclePhase);
  // Get the level for the current fmCyclePhase (0-1)
  float floatLevel = returnFrequencyModulation(fmCyclePhase);
  // If we have a bimodal modulation, then we will work with
  // levels and contrasts centered around 0 [-0.5 0.5]
  if (bimodalModFlag) {
    floatLevel = floatLevel - 0.5;
  }
  // Scale according to the fmContrast value
  floatLevel = fmContrast * floatLevel;
  // Apply any amplitude modulation
  floatLevel = returnAmplitudeModulation(amCyclePhase) * floatLevel;
  // Calculate the LED setting differently for a unimodal or a
  // bimodal modulation
  float floatSettingLED = 0;
  if (bimodalModFlag) {
    // Get the floatSettingLED as the proportional distance between
    // the background and the low or high setting value for this
    // LED as appropriate.
    if (floatLevel < 0) {
      floatLevel = max(floatLevel, -0.5);
      floatLevel = abs(floatLevel * 2);
      floatSettingLED = (background[ledIndex] - floatLevel * (background[ledIndex] - settingsLow[ledIndex])) / float(settingScale);
    } else {
      floatLevel = min(floatLevel, 0.5);
      floatLevel = floatLevel * 2;
      floatSettingLED = (background[ledIndex] + floatLevel * (settingsHigh[ledIndex] - background[ledIndex])) / float(settingScale);
    }
  } else {
    // ensure that level is within the 0-1 range
    floatLevel = max(floatLevel, 0);
    floatLevel = min(floatLevel, 1);
    // Get the floatSettingLED as the proportional
    // distance between the low and high setting value for this LED
    floatSettingLED = (floatLevel * (settingsHigh[ledIndex] - settingsLow[ledIndex]) + settingsLow[ledIndex]) / float(settingScale);
  }
  // gamma correct floatSettingLED (about 80 microseconds)
  floatSettingLED = applyGammaCorrect(floatSettingLED, ledIndex);
  // Convert the floatSettingLED to a 12 bit integer
  int settingLED = round(floatSettingLED * maxLevelVal);
  // Update the LED (about 230 microseconds)
  if (simulatePrizmatix) {
    pulseWidthModulate(settingLED);
  } else {
    writeToOneCombiLED(settingLED, ledIndex);
  }
}

float returnFrequencyModulation(float fmCyclePhase) {
  float level = 1;
  float floatCell = fmCyclePhase * (nFmModLevels - 1);
  if (interpolateWaveform) {
    // Linear interpolation between values in the fmModTable
    int lowCell = floor(floatCell);
    if (lowCell == (nFmModLevels - 1)) {
      level = float(fmModTable[lowCell]) / settingScale;
    } else {
      float mantissa = (floatCell)-lowCell;
      level = (float(fmModTable[lowCell]) + mantissa * float(fmModTable[lowCell + 1] - fmModTable[lowCell])) / settingScale;
    }
  } else {
    // Nearest-neighbor in the fmModTable
    level = float(fmModTable[round(floatCell)]) / settingScale;
  }
  return level;
}

void updateFmModTable() {
  for (int ii = 0; ii < nFmModLevels; ii++) {
    float fmCyclePhase = float(ii) / (nFmModLevels - 1);
    float modLevel = calcFrequencyModulation(fmCyclePhase);
    fmModTable[ii] = round(modLevel * settingScale);
  }
  // Set the interpolateWaveform state to false for square-wave and
  // saw-tooth profiles.
  if ((waveformIndex == 2) || (waveformIndex == 3) || (waveformIndex == 4)) {
    interpolateWaveform = false;
  } else {
    interpolateWaveform = true;
  }
}

float calcFrequencyModulation(float fmCyclePhase) {
  // Provides a continuous level, between 0-1, for a given waveform
  // at the specified phase position. We default to a half-on level
  // if not otherwise specified
  float level = 0.5;

  // Sinusoid
  if (waveformIndex == 1) {
    level = ((sin(2 * pi * fmCyclePhase) + 1) / 2);
  }
  // Square wave, off then on
  if (waveformIndex == 2) {
    if (fmCyclePhase >= 0.5) {
      level = 1;
    } else {
      level = 0;
    }
  }
  // Saw-tooth, ramping on and then sudden off
  if (waveformIndex == 3) {
    level = fmCyclePhase;
  }
  // Saw-tooth, ramping off and then sudden on
  if (waveformIndex == 4) {  // saw off
    level = 1 - fmCyclePhase;
  }
  // Compound modulation
  if (waveformIndex == 5) {
    level = 0;
    for (int ii = 0; ii < 5; ii++) {
      level = level + compoundAmps[ii] * sin(compoundHarmonics[ii] * 2 * pi * fmCyclePhase - compoundPhases[ii]);
    }
    // Use the pre-computed "compoundRange" to place level in the 0-1 range
    level = (level - compoundRange[0]) / (compoundRange[1] - compoundRange[0]);
  }
  // White noise; note that the frequency and phase values are not relevant in this case
  // Need to improve this so that the set of 8 LEDs receive the same float level to avoid
  // creating a chromatic scintillation
  if (waveformIndex == 6) {
    level = float(random(settingScale)) / settingScale;
  }
  return level;
}

float returnAmplitudeModulation(float amCyclePhase) {
  float modLevel = 1;
  // Linear interpolation between values in the amModTable
  float floatCell = amCyclePhase * (nAmModLevels - 1);
  int lowCell = floor(floatCell);
  if (lowCell == (nAmModLevels - 1)) {
    modLevel = float(amModTable[lowCell]) / settingScale;
  } else {
    float mantissa = (floatCell)-lowCell;
    modLevel = (float(amModTable[lowCell]) + mantissa * float(amModTable[lowCell + 1] - amModTable[lowCell])) / settingScale;
  }
  return modLevel;
}


void updateAmModTable() {
  for (int ii = 0; ii < nAmModLevels; ii++) {
    float amCyclePhase = float(ii) / (nAmModLevels - 1);
    float modLevel = calcAmplitudeModulation(amCyclePhase);
    amModTable[ii] = round(modLevel * settingScale);
  }
}

float calcAmplitudeModulation(float amCyclePhase) {
  float modLevel = 1.0;
  if (amplitudeIndex == 0) {
    // No amplitude modulation
  }
  if (amplitudeIndex == 1) {
    // Sinusoid amplitude modulation
    modLevel = (sin(2 * pi * amCyclePhase) + 1) / 2;
  }
  if (amplitudeIndex == 2) {
    // Half-cosine window at block onset and offset.
    float totalDurSecs = float(amCycleDurSecs) / 1e6;
    float rampDurSecs = amplitudeVals[amplitudeIndex][0];
    // Determine how far along the half-cosine ramp we are, relative
    // to the modulation frequency given by amplitudeVals[0]
    float elapsedTimeSecs = amCyclePhase * totalDurSecs;
    modLevel = 0;
    float blockOnDurSecs = totalDurSecs / 2;
    float plateauDurSecs = blockOnDurSecs - rampDurSecs;
    if (elapsedTimeSecs < rampDurSecs) {
      modLevel = (cos(pi + pi * (elapsedTimeSecs / rampDurSecs)) + 1) / 2;
    }
    if ((elapsedTimeSecs > rampDurSecs) && (elapsedTimeSecs < plateauDurSecs)) {
      modLevel = 1.0;
    }
    if ((elapsedTimeSecs > plateauDurSecs) && (elapsedTimeSecs < blockOnDurSecs)) {
      modLevel = (cos(pi * ((elapsedTimeSecs - plateauDurSecs) / rampDurSecs)) + 1) / 2;
    }
  }
  return modLevel;
}

void updateGammaTable() {
  // Loop over the LEDs
  for (int ii = 0; ii < nLEDs; ii++) {
    // Receive a set of gammaParams that specify the
    // polynomial form of the gamma correction
    float gammaParams[nGammaParams];
    for (int kk = 0; kk < nGammaParams; kk++) {
      waitForNewString();
      gammaParams[kk] = atof(inputString);
      Serial.println(gammaParams[kk]);
      clearInputString();
    }
    // Use this set of gammaParams to populate the gammaTable
    // Note we skip the first entry as this has an obligatory
    // value of zero.
    for (int jj = 1; jj < nGammaLevels - 1; jj++) {
      float input = float(jj) / (nGammaLevels - 1);
      float corrected = 0;
      for (int kk = 0; kk < nGammaParams; kk++) {
        corrected = corrected + gammaParams[kk] * pow(input, (nGammaParams - 1) - kk);
      }
      gammaTable[ii][jj] = min(round(corrected * settingScale), settingScale);
    }
    gammaTable[ii][nGammaLevels - 1] = settingScale;
  }
}

float applyGammaCorrect(float floatSettingLED, int ledIndex) {
  float corrected = 1;
  // Linear interpolation between values in the gammaTable
  float floatCell = floatSettingLED * (nGammaLevels - 1);
  int lowCell = floor(floatCell);
  if (lowCell == (nGammaLevels - 1)) {
    corrected = float(gammaTable[ledIndex][lowCell]) / settingScale;
  } else {
    float mantissa = (floatCell)-lowCell;
    corrected = (float(gammaTable[ledIndex][lowCell]) + mantissa * float(gammaTable[ledIndex][lowCell + 1] - gammaTable[ledIndex][lowCell])) / settingScale;
  }
  return corrected;
}

void updateDurVariables(float oldClockAdjustFactor, float newClockAdjustFactor) {
  fmCycleDurSecs = (fmCycleDurSecs / oldClockAdjustFactor) * newClockAdjustFactor;
  amCycleDurSecs = (amCycleDurSecs / oldClockAdjustFactor) * newClockAdjustFactor;
  modDurSecs = (modDurSecs / oldClockAdjustFactor) * newClockAdjustFactor;
  blinkDurMSecs = round((float(blinkDurMSecs) / oldClockAdjustFactor) * newClockAdjustFactor);
  rampDurMSecs = round((float(rampDurMSecs) / oldClockAdjustFactor) * newClockAdjustFactor);
}

void pulseWidthModulate(int setting) {
  // Use pulse-width modulation to vary the
  // intensity of the built in Arduino LED
  float portionOn = float(setting) / float(maxLevelVal);
  int timeOn = round(minLEDAddressTime * portionOn);
  int timeOff = minLEDAddressTime - timeOn;
  unsigned long startTime = micros();
  unsigned long currTime = micros();
  digitalWrite(LED_BUILTIN, HIGH);
  bool notDone = true;
  while (notDone) {
    currTime = micros();
    if ((currTime - startTime) > timeOn) {
      notDone = false;
    }
  }
  startTime = micros();
  digitalWrite(LED_BUILTIN, LOW);
  notDone = true;
  while (notDone) {
    currTime = micros();
    if ((currTime - startTime) > timeOff) {
      notDone = false;
    }
  }
}

// Send a setting to a wired LED
void writeToOneCombiLED(int level, int ledIndex) {
  // sanitize the input
  level = max(level, 0);
  level = min(level, maxLevelVal);
  // write the values
  Wire.beginTransmission(0x70);
  Wire.write(1 << ledIndex);
  Wire.endTransmission();
  Wire.beginTransmission(0x61);
  Wire.write(0b01011000);
  Wire.write((uint8_t)(highByte(level << 4)));
  Wire.write((uint8_t)(lowByte(level << 4)));
  Wire.endTransmission(1);
}

void pollSerialPort() {
  // Detect the case that we have received a complete string but
  // have not yet finished doing something with it. In this case,
  // do not accept anything further from the buffer
  if ((stringComplete) && (inputCharIndex == 0)) return;
  // See if there is something in the buffer
  while (Serial.available()) {
    // get the new byte:
    char inChar = (char)Serial.read();
    // add it to the inputString:
    inputString[inputCharIndex] = inChar;
    inputCharIndex++;
    if (inputCharIndex >= inputStringLen) {
      Serial.println("ERROR: Input overflow inputString buffer");
      clearInputString();
      return;
    }
    // if the incoming character is a newline,
    // set a flag so the main loop can
    // do something about it.
    if (inChar == '\n') {
      stringComplete = true;
      inputCharIndex = 0;
    }
  }
}

void waitForNewString() {
  bool stillWaiting = true;
  while (!stringComplete) {
    pollSerialPort();
  }
}

// Clean-up after receiving inputString
void clearInputString() {
  for (int ii = 0; ii < inputStringLen; ii++) {
    inputString[ii] = "";
  }
  inputCharIndex = 0;
  stringComplete = false;
}