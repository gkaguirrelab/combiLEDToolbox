////////////////////////////////////////////////////////////////////////////////
// Firmware for the Prizmatix CombiLED light engine
//
// This code supports the presentation of temporal modulations of the
// spectral content of light generated by the CombiLED device. The device
// contains 8, narrow-band LEDs under the control of an Arduino Uno.
//
// The LEDs have the following spectroradiometric properties:
//            peak (nm)    FWHM (nm)     power (mW_)
//  LED0 --   405          14            1900
//  LED1 --   424          27            750
//  LED2 --   470          21            460
//  LED3 --   498          22            295
//  LED4 --   540          67            680
//  LED5 --   598          14            88
//  LED6 --   627          19            480
//  LED7 --   561          15            470
//
// The "settings" vectors specifies the highest and lowest intensity level
// of each LED between 0 and 1 with 1e-4 precision. Over time, a waveform
// defines a linear transition between the high and the low state,
// producing (for example) a linear change in luminance or Lâ€“M contrast,
// for example. Gamma correction is performed on device, and the resulting
// floating level is then cast into a 12 bit LED setting
//
// The modulation is under the control of a waveform (e.g., sin, square) and
// a frequency [Hz]. After
// setup, the code enters a run loop during which each LED is updated
// sequentially. The waveform is used to define a floating point level (0-1),
// which is mapped between the low an high settings values.
//
// There is a minimum amount of time required to address an LED (about 250
// microseconds). The program clock advances and, at this interval, determines
// where we are in the waveform cycle and updates the next LED to the setting
// for that LED. As a consequence, different LEDs oscillate at different phase
// delays of the waveform. As the waveform frequency is unlikely to be
// synchronized to the minimum LED refresh rate, this phase delay will precess
// across waveform cycles. This can cause aliasing of the modulation to lower
// frequencies. To ameliorate this, the LEDs are updated in an interleaved order.
//
// If an LED has settings that never vary from the background, then that LED
// is marked as "inactive", and skipped in the sequential updating. This allows
// the remaining, active LEDs to be updated more frequently.
//
// In addition to the frequency modulation of the waveform, a superimposed
// amplitude modulation may be specified.
//
// In operation, the firmware supports placing the device in three states:
//  RUN MODE (RM) -- continuously present the specified modulation
//  CONFIG MODE (CM) -- change the parameters of the modulation
//  DIRECT MODE (DM) -- pass setting values directly to the LEDs; this
//                      mode is used when performing device calibration.
//
// Global variables of note:
//  simulatePrizmatix   Boolean. If set to true, the code treats the Arduino
//                      built-in LED as LED0. The intensity of the LED is
//                      pulse-width modulated. The other 7 channels are ignored.
//  maxLevelVal         4095. This is the max of the 12-bit range.
//  minLEDAddressTime   Scalar, microseconds. We find that it takes 234 microsecs
//                      to write a setting to one LED. We set this minimum address
//                      time to somewhat longer than this to allow time for
//                      computation overhead.
//  settingsHigh, settingsLow 8x1 int matrix, all between 0 and 1e4. Each value
//                      defines the high or low setting for each of the 8 LEDs.
//                      The specified value is divided
//                      by 1e4 to yield a value between 0 and 1. This value is
//                      subject to gamma correction prior to being passed to the
//                      LED.
//  background          8x1 int array of value 0-1e4. Specifies the
//                      background level for each LED.
//  contrast            Float, between 0 and 1. Defines the contrast of the
//                      modulation relative to its maximum.
//  gammaParams         8x6 float matrix. Defines the parameters of a 5th order
//                      polynomial (plus an offset) that define the conversion
//                      of the desired intensity level to the corresponding
//                      device level for each LED.
//  waveformIndex       Scalar. Defines the waveform profile to be used:
//                        0 - no modulation (stay at background)
//                        1 - sinusoid
//                        2 - square wave (off-on)
//                        3 - saw-tooth on
//                        4 - saw-tooth off
//                        5 - compound modulation
//  cycleDur            Scalar. The duration in microseconds of the waveform.
//  phaseOffset         Float, 0-2pi. Used to shift the phase of the waveform.
//  amplitudeIndex      Scalar. Defines the amplitude modulation profile:
//                        0 - none
//                        1 - sinusoid modulation
//                        2 - half-cosine window
//  amplitudeVals       2x1 float array. Values control the amplitude modulation,
//                      varying by the amplitudeIndex:
//                        0 - [unused, unused]
//                        1 - [frequency Hz, modulation depth 0-1]
//                        2 - [block frequency (on then off), half-cosine duration]
//  blinkDurationMSecs  Scalar. Duration of attention event in milliseconds.
//                      During run-mode, passing a "blink" command sets all LEDs
//                      to zero for the blink duration. Default is 100 msecs.
//  ledUpdateOrder      8x1 int array, of values 0-7. Defines the order in which
//                      the LEDs are updated across the cycle. By default, the order
//                      interleaves LEDs.
//
//
//

// package to write to the LEDs
#include <Wire.h>


///////////////////// SIMULATE PRIZMATIX /////////////////////////////
// Set this variable to use the built-in LED to simulate
// the output of the Prizmatix device
//
bool simulatePrizmatix = false;
/////////////////////////////////////////////////////////////////////


///////////////////// DIRECT MODE BEHAVIOR //////////////////////////
// Direct mode is used to calibrate the device. This flag controls
// if the settings that are sent in direct mode are subjected to the
// on-board gamma correction. If the device is being calibrated, we
// generally do not want to gamma correct, as part of the purpose of
// calibration is to measure the gamma table. The primary use of this
// flag is to conduct a test to confirm that the on-board gamma
// correction yields a linear-appearing set of responses in a
// calibration measure that uses this correction.
//
bool gammaCorrectInDirectMode = false;
/////////////////////////////////////////////////////////////////////



// Fixed hardware values
const int maxLevelVal = 4095;       // maximum setting value for the prizmatix LEDs
const int minLEDAddressTime = 300;  // the time, in microseconds, required to send an LED setting

// Fixed reality values
const float pi = 3.1415927;

// Fixed value that scales the settings and background values to floats between 0 and 1
const int settingScale = 1e4;

// Define the device states
enum { CONFIG,
       RUN,
       DIRECT } deviceState = RUN;

// Global and control variables
const uint8_t inputStringLen = 12;  // size of the string buffer used to send commands
char inputString[inputStringLen];   // a character vector to hold incoming data
uint8_t inputCharIndex = 0;         // index to count our accumulated characters
bool stringComplete = false;        // whether the input string is complete
bool modulationState = false;       // When we are running, are we modulating?

// Define settings and modulations
const uint8_t nLEDs = 8;  // the number of LEDs

// Define a set of gamma functions. Each gamma function is a 5th order polynomial (plus a
// constant) that maps an input setting to an output setting
const int nGammaParams = 6;
float gammaParams[nLEDs][nGammaParams] = {
  { 0.4926, -1.0036, 0.8240, -0.0330, 0.7225, 0.0017 },
  { -0.6430, 1.9306, -2.1050, 1.6427, 0.1740, -0.0001 },
  { 3.4778, -8.7622, 8.5862, -3.3875, 1.0847, 0.0018 },
  { -0.0841, 1.0015, -1.1905, 0.9454, 0.3296, 0.0003 },
  { -0.5600, 1.7310, -1.8954, 1.2862, 0.4387, -0.0000 },
  { -0.9650, 3.3443, -3.6143, 1.7453, 0.4884, -0.0011 },
  { 1.5295, -2.8669, 1.9364, -0.3914, 0.7950, -0.0003 },
  { -1.1093, 3.3198, -3.5685, 1.6895, 0.6688, -0.0007 },
};

// Light Flux, ~100 % contrast
int settingsLow[nLEDs] = { 0, 0, 0, 0, 0, 0, 0, 0 };
int settingsHigh[nLEDs] = { 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000 };
int background[nLEDs] = { 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000 };

// Adjust the overall contrast of the modulation between 0 and 1
float contrast = 1;

// The ledIsActive vector is regenerated whenever the settings or background
// changes. The idea is to skip updating LEDs if their settings never change
// from the background. Set to false initially, but we will check and update
// this before entering the loop.
bool ledIsActive[nLEDs] = { false, false, false, false, false, false, false, false };

// Variables that define an amplitude modulation
uint8_t amplitudeIndex = 0;  // Default to no amplitude modulation
float amplitudeVals[4][2] = {
  { 0.0, 0.0 },  // unused entries for no amplitude modulation
  { 0.1, 1.0 },  // AM modulation: frequency Hz, AM depth
  { 0.1, 1.5 },  // Half-cosine window: block frequency Hz, window duration seconds
  { 0.1, 2 },    // Modulate the phase of the index 2 harmonic of the compound modulation
};

// Variables the define compound modulations. Support is provided for a compound modulation
// composed of up to 5 sinusoids. For each sinusoid, we specify the harmonic index relative
// to the fundamental FM modulation frequency (0 for no modulation), the relative amplitude
// of that harmonic component, and the relative phase (in radians). Finally, we need to know
// the min and max values across a full cycle of a given compound waveform. The compoundRange
// variable holds the result. See the function "updateCompoundRange" for details.
float compoundHarmonics[5] = { 1, 2, 4, 0, 0 };         // Multiples of the fundamental
float compoundAmps[5] = { 0.5, 1, 1, 0, 0 };            // Relative amplitudes
float compoundPhases[5] = { 0, 0.7854, 4.3633, 0, 0 };  // Phase delay in radians
float compoundRange[2] = { 0, 1 };

// Timing variables
uint8_t waveformIndex = 1;                              // Default to sinusoid
unsigned long cycleDur = round(1e6 / 3);                // Initialize at 3 Hz
unsigned long modulationStartTime = micros();           // Initialize these with the clock
unsigned long lastLEDUpdateTime = micros();             // Initialize these with the clock
int blinkDurationMSecs = 100;                           // Default duration of the blink event in msecs
uint8_t ledCycleIdx = 0;                                // Counter to index our cycle through updating LEDs
float phaseOffset = 0;                                  // 0-2pi, used to shift the waveform phase
uint8_t ledUpdateOrder[] = { 0, 2, 4, 6, 1, 3, 5, 7 };  // The order in which LEDs are updated
float modulationDurSecs = 0;                            // Duration of the modulation in secs (0 for continuous)
int long cycleCount = 0;                                // Num cycles elapsed since modulation start



// setup
void setup() {
  // Initialize serial port communication
  Serial.begin(57600);
  // Modify the settings and background if we are simulating
  if (simulatePrizmatix) {
    for (int ii = 1; ii < nLEDs; ii++) {
      settingsHigh[ii] = 0;
      settingsLow[ii] = 0;
      background[ii] = 0;
    }
  }
  // Initialize communication with the LED(s)
  if (simulatePrizmatix) {
    // Use the built-in LED
    pinMode(LED_BUILTIN, OUTPUT);
  } else {
    // USe the wired LEDs
    Wire.begin();
    Wire.setClock(400000);
  }
  // Check which LEDs are "active"
  identifyActiveLEDs();
  // Set the device to background
  setToBackground();
  // Update the compoundRange, in case we have
  // a compound modulation to start
  updateCompoundRange();
  // Show the console menu
  showModeMenu();
}

// loop
void loop() {
  // Handle inputs dependent upon the deviceState
  switch (deviceState) {
    case CONFIG:
      getConfig();
      break;
    case DIRECT:
      getDirect();
      break;
    case RUN:
      getRun();
      break;
  }
  // Advance the LED settings
  if (modulationState) {
    unsigned long currentTime = micros();
    if ((currentTime - lastLEDUpdateTime) > minLEDAddressTime) {
      // Determine where we are in the cycle
      unsigned long cycleTime = ((currentTime - modulationStartTime) % cycleDur);
      double cyclePhase = double(cycleTime) / double(cycleDur);
      // Update the lastTime
      lastLEDUpdateTime = currentTime;
      // Update the next LED
      updateLED(cyclePhase, ledUpdateOrder[ledCycleIdx]);
      // Advance the ledCycleIdx
      ledCycleIdx++;
      ledCycleIdx = ledCycleIdx % nLEDs;
    }
    // Check if we have exceeded the modulation duration
    if (modulationDurSecs > 0) {
      float elapsedTimeSecs = (currentTime - modulationStartTime) / 1e6;
      if (elapsedTimeSecs > modulationDurSecs) {
        modulationState = false;
        setToBackground();
      }
    }
  }
}

// Had to comment out the menu details as these serial entries
// eat up dynamic memory space.
void showModeMenu() {
  switch (deviceState) {
    case CONFIG:
      Serial.println("CM");
      break;
    case DIRECT:
      Serial.println("DM");
      break;
    case RUN:
      Serial.println("RM");
      break;
  }
}

void getConfig() {
  // Operate in modal state waiting for input
  waitForNewString();
  if (strncmp(inputString, "WF", 2) == 0) {
    // waveformIndex controls the FM modulation form
    Serial.println("WF:");
    clearInputString();
    waitForNewString();
    waveformIndex = atoi(inputString);
    if (waveformIndex == 0) Serial.println("none");
    if (waveformIndex == 1) Serial.println("sin");
    if (waveformIndex == 2) Serial.println("square");
    if (waveformIndex == 3) Serial.println("sawon");
    if (waveformIndex == 4) Serial.println("sawoff");
    if (waveformIndex == 5) {
      Serial.println("compound");
      updateCompoundRange();
    }
  }
  if (strncmp(inputString, "FQ", 2) == 0) {
    // Carrier modulation frequency (float Hz)
    Serial.println("FQ:");
    clearInputString();
    waitForNewString();
    cycleDur = 1e6 / atof(inputString);
    Serial.println(atof(inputString));
  }
  if (strncmp(inputString, "MD", 2) == 0) {
    // Modulation duration (float seconds)
    // Set to zero to have the modulation
    // continue until stopped
    Serial.println("MD:");
    clearInputString();
    waitForNewString();
    modulationDurSecs = atof(inputString);
    Serial.println(atof(inputString));
  }
  if (strncmp(inputString, "CN", 2) == 0) {
    // Contrast (0-1 float)
    Serial.println("CN:");
    clearInputString();
    waitForNewString();
    contrast = atof(inputString);
    Serial.println(atof(inputString));
  }
  if (strncmp(inputString, "PH", 2) == 0) {
    // Phase offset (0-2pi float)
    Serial.println("PH:");
    clearInputString();
    waitForNewString();
    phaseOffset = atof(inputString);
    Serial.println(atof(inputString));
  }
  if (strncmp(inputString, "AM", 2) == 0) {
    // Amplitude modulation index
    Serial.println("AM:");
    clearInputString();
    waitForNewString();
    amplitudeIndex = atoi(inputString);
    if (amplitudeIndex == 0) Serial.println("none");
    if (amplitudeIndex == 1) Serial.println("sin");
    if (amplitudeIndex == 2) Serial.println("half-cos");
    if (amplitudeIndex == 3) Serial.println("compound phase shift");
  }
  if (strncmp(inputString, "AV", 2) == 0) {
    // Amplitude modulation values for the current index
    Serial.println("AV0:");
    clearInputString();
    waitForNewString();
    float newVal = atof(inputString);
    amplitudeVals[amplitudeIndex][0] = newVal;
    Serial.println("AV1:");
    clearInputString();
    waitForNewString();
    newVal = atof(inputString);
    amplitudeVals[amplitudeIndex][1] = newVal;
    Serial.println(".");
  }
  if (strncmp(inputString, "CH", 2) == 0) {
    // Compound modulation, 5 harmonic indices
    Serial.println("CH:");
    clearInputString();
    for (int ii = 0; ii < 5; ii++) {
      waitForNewString();
      float newVal = atof(inputString);
      compoundHarmonics[ii] = newVal;
      Serial.println(".");
      clearInputString();
    }
    updateCompoundRange();
  }
  if (strncmp(inputString, "CA", 2) == 0) {
    // Compound modulation, 5 harmonic amplitudes
    Serial.println("CA:");
    clearInputString();
    for (int ii = 0; ii < 5; ii++) {
      waitForNewString();
      float newVal = atof(inputString);
      compoundAmps[ii] = newVal;
      Serial.println(".");
      clearInputString();
    }
    updateCompoundRange();
  }
  if (strncmp(inputString, "CP", 2) == 0) {
    // Compound modulation, 5 harmonic phases
    Serial.println("CP:");
    clearInputString();
    for (int ii = 0; ii < 5; ii++) {
      waitForNewString();
      float newVal = atof(inputString);
      compoundPhases[ii] = newVal;
      Serial.println(".");
      clearInputString();
    }
    updateCompoundRange();
  }
  if (strncmp(inputString, "ST", 2) == 0) {
    // Matrix of settings int, 0-1e4, first
    // settingsLow, then settingsHigh
    Serial.println("ST:");
    clearInputString();
    for (int ii = 0; ii < nLEDs; ii++) {
      waitForNewString();
      int level = atoi(inputString);
      settingsLow[ii] = level;
      Serial.println(".");
      clearInputString();
    }
    for (int ii = 0; ii < nLEDs; ii++) {
      waitForNewString();
      int level = atoi(inputString);
      settingsHigh[ii] = level;
      Serial.println(".");
      clearInputString();
    }
  }
  identifyActiveLEDs();
  if (strncmp(inputString, "GP", 2) == 0) {
    // Matrix of gamma parameters (float)
    Serial.println("GP:");
    clearInputString();
    for (int ii = 0; ii < nLEDs; ii++) {
      for (int jj = 0; jj < nGammaParams; jj++) {
        waitForNewString();
        gammaParams[ii][jj] = atof(inputString);
        Serial.println(".");
        clearInputString();
      }
    }
    identifyActiveLEDs();
  }
  if (strncmp(inputString, "BG", 2) == 0) {
    // Matrix of background settings int, 0-1e4
    Serial.println("BG:");
    clearInputString();
    for (int ii = 0; ii < nLEDs; ii++) {
      waitForNewString();
      int level = atoi(inputString);
      background[ii] = level;
      Serial.println(".");
      clearInputString();
    }
    identifyActiveLEDs();
    setToBackground();
  }
  if (strncmp(inputString, "RM", 2) == 0) {
    // Switch to run mode
    modulationState = false;
    deviceState = RUN;
    setToBackground();
    showModeMenu();
  }
  if (strncmp(inputString, "DM", 2) == 0) {
    // Switch to direct control mode
    modulationState = false;
    deviceState = DIRECT;
    showModeMenu();
  }
  clearInputString();
}

void getDirect() {
  // Operate in modal state waiting for input
  waitForNewString();

  // The primary Direct mode activity: send a
  // vector of settings for the LEDs.
  if (strncmp(inputString, "LL", 2) == 0) {
    Serial.println("LL:");
    clearInputString();
    for (int ii = 0; ii < nLEDs; ii++) {
      waitForNewString();
      int level = atoi(inputString);
      Serial.println(".");
      clearInputString();
      // Convert 1e4 level to a 0-1 float level
      float ledSettingFloat = float(level) / float(settingScale);
      // gamma correct ledSettingFloat
      if (gammaCorrectInDirectMode) ledSettingFloat = gammaCorrect(ledSettingFloat, ii);
      // Convert the ledSettingFloat to a 12 bit integer
      int ledSetting = round(ledSettingFloat * maxLevelVal);
      if (simulatePrizmatix) {
        pulseWidthModulate(ledSetting);
      } else {
        writeToOneCombiLED(ledSetting, ii);
      }
    }
  }
  if (strncmp(inputString, "DK", 2) == 0) {
    setToOff();
    Serial.println(".");
    modulationState = false;
  }
  if (strncmp(inputString, "RM", 2) == 0) {
    modulationState = false;
    deviceState = RUN;
    setToBackground();
    showModeMenu();
  }
  if (strncmp(inputString, "CM", 2) == 0) {
    modulationState = false;
    deviceState = CONFIG;
    showModeMenu();
  }
  clearInputString();
}

void getRun() {
  // Operate in amodal state; only act if we have
  // a complete string
  pollSerialPort();
  if (stringComplete) {
    stringComplete = false;
    if (strncmp(inputString, "GO", 2) == 0) {
      Serial.println(".");
      modulationState = true;
      lastLEDUpdateTime = micros();
      modulationStartTime = micros();
    }
    if (strncmp(inputString, "SP", 2) == 0) {
      setToBackground();
      Serial.println(".");
      modulationState = false;
    }
    if (strncmp(inputString, "BL", 2) == 0) {
      Serial.println(".");
      setToOff();
      delay(blinkDurationMSecs);
      setToBackground();
    }
    if (strncmp(inputString, "BG", 2) == 0) {
      setToBackground();
      Serial.println(".");
      modulationState = false;
    }
    if (strncmp(inputString, "DK", 2) == 0) {
      setToOff();
      Serial.println(".");
      modulationState = false;
    }
    if (strncmp(inputString, "DM", 2) == 0) {
      modulationState = false;
      setToBackground();
      deviceState = DIRECT;
      showModeMenu();
    }
    if (strncmp(inputString, "CM", 2) == 0) {
      modulationState = false;
      setToBackground();
      deviceState = CONFIG;
      showModeMenu();
    }
    clearInputString();
  }
}

void pollSerialPort() {
  // Detect the case that we have received a complete string but
  // have not yet finished doing something with it. In this case,
  // do not accept anything further from the buffer
  if ((stringComplete) && (inputCharIndex == 0)) return;
  // See if there is something in the buffer
  while (Serial.available()) {
    // get the new byte:
    char inChar = (char)Serial.read();
    // add it to the inputString:
    inputString[inputCharIndex] = inChar;
    inputCharIndex++;
    if (inputCharIndex >= inputStringLen) {
      Serial.println("ERROR: Input overflow inputString buffer");
      clearInputString();
      return;
    }
    // if the incoming character is a newline,
    // set a flag so the main loop can
    // do something about it.
    if (inChar == '\n') {
      stringComplete = true;
      inputCharIndex = 0;
    }
  }
}

void waitForNewString() {
  bool stillWaiting = true;
  while (!stringComplete) {
    pollSerialPort();
  }
}

void updateCompoundRange() {
  // Handle compound modulations. We need
  // to scale the waveform between 0 and 1. Here we examine
  // waveform across an entire cycle and store the range to be
  // used later to scale the levels to within 0 and 1.
  if (waveformIndex < 5) return;
  compoundRange[0] = 0;
  compoundRange[1] = 1;
  float newRange[2] = { 0, 0 };
  float phase = 0;
  float level = 0;
  for (int ii = 0; ii < 1000; ii++) {
    phase = float(ii) / 1000;
    level = getFrequencyModulation(phase);
    newRange[0] = min(newRange[0], level);
    newRange[1] = max(newRange[1], level);
  }
  compoundRange[0] = newRange[0];
  compoundRange[1] = newRange[1];
}

void identifyActiveLEDs() {
  // Identify those LEDs that are pinned and remove them from the active list
  for (int ii = 0; ii < nLEDs; ii++) {
    if (settingsHigh[ii] == settingsLow[ii]) {
      ledIsActive[ii] = false;
    } else {
      ledIsActive[ii] = true;
    }
  }
}

void setToBackground() {
  for (int ii = 0; ii < nLEDs; ii++) {
    // Get the setting for this LED
    float ledSettingFloat = float(background[ii]) / float(settingScale);
    // gamma correct ledSettingFloat
    ledSettingFloat = gammaCorrect(ledSettingFloat, ii);
    // Convert the ledSettingFloat to a 12 bit integer
    int ledSetting = round(ledSettingFloat * maxLevelVal);
    if (simulatePrizmatix) {
      if (ledSetting > (maxLevelVal / 2)) {
        digitalWrite(LED_BUILTIN, HIGH);
      } else {
        digitalWrite(LED_BUILTIN, LOW);
      }
    } else {
      writeToOneCombiLED(ledSetting, ii);
    }
  }
}

void setToOff() {
  if (simulatePrizmatix) {
    // Use the built in Arduino LED, which has a binary state
    digitalWrite(LED_BUILTIN, LOW);
  } else {
    // Loop through the LEDs and set them to zero
    for (int ii = 0; ii < nLEDs; ii++) {
      writeToOneCombiLED(0, ii);
    }
  }
}

void updateLED(double cyclePhase, int ledIndex) {
  // Check if the current LED is marked as active
  if (ledIsActive[ledIndex]) {
    // Adjust the cyclePhase for the phaseOffset
    cyclePhase = cyclePhase + (phaseOffset / (2 * pi));
    // Get the level for the current cyclePhase
    float floatLevel = getFrequencyModulation(cyclePhase);
    // Get the background level for this LED
    float offset = float(background[ledIndex]) / float(settingScale);
    // Scale according to the contrast value
    floatLevel = contrast * (floatLevel - offset) + offset;
    // Apply any amplitude modulation
    floatLevel = applyAmplitudeModulation(floatLevel, offset);
    // Get the float intensity setting as the linear proportional
    // distance between the low and high value
    float ledSettingFloat = (floatLevel * (settingsHigh[ledIndex] - settingsLow[ledIndex]) + settingsLow[ledIndex]) / float(settingScale);
    // gamma correct ledSettingFloat
    ledSettingFloat = gammaCorrect(ledSettingFloat, ledIndex);
    // Convert the ledSettingFloat to a 12 bit integer
    int ledSetting = round(ledSettingFloat * maxLevelVal);
    // Update the LED
    if (simulatePrizmatix) {
      pulseWidthModulate(ledSetting);
    } else {
      writeToOneCombiLED(ledSetting, ledIndex);
    }
  }
}

float getFrequencyModulation(float cyclePhase) {
  // Provides a continuous level, between 0-1, for a given waveform
  // at the specified phase position. We default to a half-on level
  // if not otherwise specified
  float level = 0.5;

  // Sinusoid
  if (waveformIndex == 1) {
    level = ((sin(2 * pi * cyclePhase) + 1) / 2);
  }
  // Square wave, off then on
  if (waveformIndex == 2) {
    if (cyclePhase >= 0.5) {
      level = 1;
    } else {
      level = 0;
    }
  }
  // Saw-tooth, ramping on and then sudden off
  if (waveformIndex == 3) {
    level = cyclePhase;
  }
  // Saw-tooth, ramping off and then sudden on
  if (waveformIndex == 4) {  // saw off
    level = 1 - cyclePhase;
  }
  // Compound modulation
  if (waveformIndex == 5) {
    level = 0;
    for (int ii = 0; ii < 5; ii++) {
      level = level + compoundAmps[ii] * sin(compoundHarmonics[ii] * 2 * pi * cyclePhase - compoundPhases[ii]);
    }
    // Use the pre-computed "compoundRange" to place level in the 0-1 range
    level = (level - compoundRange[0]) / (compoundRange[1] - compoundRange[0]);
  }
  return level;
}

float applyAmplitudeModulation(float level, float offset) {
  // Sinusoid amplitude modulation
  if (amplitudeIndex == 1) {
    float AMFrequencyHz = amplitudeVals[amplitudeIndex][0];
    float AMDepth = amplitudeVals[amplitudeIndex][1];
    // Determine how far along the modulation we are
    float elapsedTimeSecs = (micros() - modulationStartTime) / 1e6;
    float modLevel = AMDepth * (sin(2 * pi * (elapsedTimeSecs / (1 / AMFrequencyHz))) + 1) / 2;
    // center the level around the background
    level = (level - offset) * modLevel + offset;
  }
  // Half-cosine window at block onset and offset
  if (amplitudeIndex == 2) {
    float totalDur = 1 / amplitudeVals[amplitudeIndex][0];
    float rampDur = amplitudeVals[amplitudeIndex][1];
    // Determine how far along the half-cosine ramp we are, relative
    // to the modulation frequency given by amplitudeVals[0]
    double elapsedTimeSecs = fmod((micros() - modulationStartTime) / 1e6, totalDur);
    float modLevel = 0;
    float blockOnDur = totalDur / 2;
    float plateauDur = blockOnDur - rampDur;
    if (elapsedTimeSecs < rampDur) {
      modLevel = (cos(pi + pi * (elapsedTimeSecs / rampDur)) + 1) / 2;
    }
    if ((elapsedTimeSecs > rampDur) && (elapsedTimeSecs < plateauDur)) {
      modLevel = 1.0;
    }
    if ((elapsedTimeSecs > plateauDur) && (elapsedTimeSecs < blockOnDur)) {
      modLevel = (cos(pi * ((elapsedTimeSecs - plateauDur) / rampDur)) + 1) / 2;
    }
    // center the level around the background
    level = (level - offset) * modLevel + offset;
  }
    // Vary the phase of a compound modulation harmonic
  if (amplitudeIndex == 3) {
    float totalDur = 1 / amplitudeVals[amplitudeIndex][0];
    int harmonicIdx = amplitudeVals[amplitudeIndex][1];
    // Determine how far along the modulation we are
    float elapsedTimeSecs = (micros() - modulationStartTime) / 1e6;
    float harmPhase = 2 * pi * (elapsedTimeSecs / totalDur);
    compoundPhases[harmonicIdx] = harmPhase;
  }
  // ensure that level is within the 0-1 range
  level = max(level, 0);
  level = min(level, 1);
  return level;
}

float gammaCorrect(float ledSettingFloat, int ledIndex) {
  float corrected = 0;
  for (int ii = 0; ii < nGammaParams; ii++) {
    corrected = corrected + gammaParams[ledIndex][ii] * pow(ledSettingFloat, (nGammaParams - 1) - ii);
  }
  return corrected;
}

void pulseWidthModulate(int setting) {
  // Use pulse-width modulation to vary the
  // intensity of the built in Arduino LED
  float portionOn = float(setting) / float(maxLevelVal);
  int timeOn = round(minLEDAddressTime * portionOn);
  int timeOff = minLEDAddressTime - timeOn;
  unsigned long startTime = micros();
  unsigned long currTime = micros();
  digitalWrite(LED_BUILTIN, HIGH);
  bool notDone = true;
  while (notDone) {
    currTime = micros();
    if ((currTime - startTime) > timeOn) {
      notDone = false;
    }
  }
  startTime = micros();
  digitalWrite(LED_BUILTIN, LOW);
  notDone = true;
  while (notDone) {
    currTime = micros();
    if ((currTime - startTime) > timeOff) {
      notDone = false;
    }
  }
}

// Send a setting to an wired LED
void writeToOneCombiLED(int level, int ledIndex) {
  // sanitize the input
  level = max(level, 0);
  level = min(level, maxLevelVal);
  // write the values
  Wire.beginTransmission(0x70);
  Wire.write(1 << ledIndex);
  Wire.endTransmission();
  Wire.beginTransmission(0x61);
  Wire.write(0b01011000);
  Wire.write((uint8_t)(highByte(level << 4)));
  Wire.write((uint8_t)(lowByte(level << 4)));
  Wire.endTransmission(1);
}

// Clean-up after receiving inputString
void clearInputString() {
  for (int ii = 0; ii < inputStringLen; ii++) {
    inputString[ii] = "";
  }
  inputCharIndex = 0;
  stringComplete = false;
}