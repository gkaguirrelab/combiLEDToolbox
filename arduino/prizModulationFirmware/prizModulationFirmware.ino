// Firmware for the Prizmatix CombiLED light engine
//
// This code supports the presentation of temporal modulations of the
// spectral content of light generated by the CombiLED device. The device
// contains 8, narrow-band LEDs under the control of an Arduino Uno. Each
// LED can be set to an intensity with 12 bit depth (0-4095). Practically, we
// pre-define an ordered set of 40 different levels across the LEDs. The 40
// levels might define a linear change in luminance contrast, or Lâ€“M contrast.
// This is the "settings" matrix.
//
// Over time, we present a given column of the settings by assigning the 8 
// values to the 8 LEDs. The particular column that is presented is under the
// control of a waveform (e.g., sin, square) and a frequency [Hz]. After 
// completing setup and configuration, the code enters a run loop during which
// each LED is updated in turn. The waveform is used to define a floating point
// level (0-1), which is mapped to the range of 40, fixed levels (0-39). The
// settings matrix provides the setting of the given LED at the given level.
//
// There is a minimum amount of time required to address an LED. For frequencies
// above ~ 8 Hz, there is insufficient time to present all 40 levels of (e.g.) a
// sinusoidal modulation for all LEDs. 
//
//
// maxVal:                  Int. The maximum setting value for any LED (4095)
// settingsMatrix:          8 x n matrix of ints, all between 0 and maxVal.
//                          Each column defines the settings on the 8 LEDs at
//                          each of n levels of the modulation.
// waveform:                r x 1 integer vector, where each value is between
//                          0 and n-1. As we step through time points, the
//                          waveform defines the profile of the cycle. A typical
//                          option would be for the waveform to define a
//                          sinusoidal transition between settings.
//
//

// package to write to the LEDs
#include <Wire.h>

///////////////////// SIMULATE PRIZMATIX /////////////////////////////
// Set this variable to use the built-in LED to simulate
// the output of the Prizmatix device
//
bool simulatePrizmatix = true;  // Simulate the prizmatix LEDs

// Fixed hardware values
const int maxVal = 4095;            // maximum setting value for the prizmatix LEDs
const int minLEDAddressTime = 360;  // the time, in microseconds, required refresh an LED setting

// Fixed reality values
const float pi = 3.1415927;

// Global variables
String inputString = "";       // a String to hold incoming data
bool stringComplete = false;   // whether the string is complete
bool configMode = false;       // stay in setup mode until commanded otherwise
bool modulationState = false;  // When we are running, are we modulating?

// Define settings and modulations
const int nLEDs = 8;     // number of LEDs defining the number of rows of the settings matrix.
const int nLevels = 40;  // the number of modulation levels that are specified for each LEDint waveform = 1;  // sinusoid
int settings[nLEDs][nLevels] = {
  { 0, 105, 210, 315, 420, 525, 630, 735, 840, 945, 1050, 1155, 1260, 1365, 1470, 1575, 1680, 1785, 1890, 1995, 2100, 2205, 2310, 2415, 2520, 2625, 2730, 2835, 2940, 3045, 3150, 3255, 3360, 3465, 3570, 3675, 3780, 3885, 3990, 4095 },  //LED0
  { 0, 105, 210, 315, 420, 525, 630, 735, 840, 945, 1050, 1155, 1260, 1365, 1470, 1575, 1680, 1785, 1890, 1995, 2100, 2205, 2310, 2415, 2520, 2625, 2730, 2835, 2940, 3045, 3150, 3255, 3360, 3465, 3570, 3675, 3780, 3885, 3990, 4095 },  //LED0
  { 0, 105, 210, 315, 420, 525, 630, 735, 840, 945, 1050, 1155, 1260, 1365, 1470, 1575, 1680, 1785, 1890, 1995, 2100, 2205, 2310, 2415, 2520, 2625, 2730, 2835, 2940, 3045, 3150, 3255, 3360, 3465, 3570, 3675, 3780, 3885, 3990, 4095 },  //LED0
  { 0, 105, 210, 315, 420, 525, 630, 735, 840, 945, 1050, 1155, 1260, 1365, 1470, 1575, 1680, 1785, 1890, 1995, 2100, 2205, 2310, 2415, 2520, 2625, 2730, 2835, 2940, 3045, 3150, 3255, 3360, 3465, 3570, 3675, 3780, 3885, 3990, 4095 },  //LED0
  { 0, 105, 210, 315, 420, 525, 630, 735, 840, 945, 1050, 1155, 1260, 1365, 1470, 1575, 1680, 1785, 1890, 1995, 2100, 2205, 2310, 2415, 2520, 2625, 2730, 2835, 2940, 3045, 3150, 3255, 3360, 3465, 3570, 3675, 3780, 3885, 3990, 4095 },  //LED0
  { 0, 105, 210, 315, 420, 525, 630, 735, 840, 945, 1050, 1155, 1260, 1365, 1470, 1575, 1680, 1785, 1890, 1995, 2100, 2205, 2310, 2415, 2520, 2625, 2730, 2835, 2940, 3045, 3150, 3255, 3360, 3465, 3570, 3675, 3780, 3885, 3990, 4095 },  //LED0
  { 0, 105, 210, 315, 420, 525, 630, 735, 840, 945, 1050, 1155, 1260, 1365, 1470, 1575, 1680, 1785, 1890, 1995, 2100, 2205, 2310, 2415, 2520, 2625, 2730, 2835, 2940, 3045, 3150, 3255, 3360, 3465, 3570, 3675, 3780, 3885, 3990, 4095 },  //LED0
  { 0, 105, 210, 315, 420, 525, 630, 735, 840, 945, 1050, 1155, 1260, 1365, 1470, 1575, 1680, 1785, 1890, 1995, 2100, 2205, 2310, 2415, 2520, 2625, 2730, 2835, 2940, 3045, 3150, 3255, 3360, 3465, 3570, 3675, 3780, 3885, 3990, 4095 },  //LED0
};
int background[nLEDs] = { 20, 20, 20, 20, 20, 20, 20, 20 };
bool ledIsActive[nLEDs] = { true, true, true, true, true, true, true, true };

// Variables that define an amplitude modulation
int ampModType = 0;
float ampVals[3][2] = {
  { 0.0, 0.0 },  // no amplitude modulation
  { 0.1, 1.5 },  // Half-cosine window: block frequency Hz, window duration seconds
  { 0.1, 1.0 },  // AM modulation: frequency Hz, AM depth
};

// timing variables
int waveform = 5;
unsigned long cycleDur = 1e6 / 4;  // initialize at 10 Hz
unsigned long modulationStartTime = micros();
unsigned long lastLEDUpdateTime = micros();
float blinkDurationSecs = 0.25;
int cycleLED = 0;

// setup
void setup() {

  // Initialize serial port communication
  Serial.begin(57600);

  // Modify the settings if we are simulating
  if (simulatePrizmatix) {
    for (int ii = 1; ii < nLEDs; ii++) {
      for (int jj = 0; jj < nLevels; jj++) {
        settings[ii][jj] = 0;
      }
      background[ii] = 0;
    }
  }

  // Set up the built-in LED if we are simulating
  if (simulatePrizmatix) {
    pinMode(LED_BUILTIN, OUTPUT);
  } else {
    Wire.begin();
    Wire.setClock(400000);
  }

  // Check which LEDs are "active"
  identifyActiveLEDs();

  // Set the device to background
  setToBackground();

  // Announce we are starting
  Serial.println("== run mode");
}

void loop() {

  // If configMode, go wait for the next input
  if (configMode) {
    getConfig();
    return;
  }

  // We are in run mode. Poll the serial port, and cycle the LED settings
  pollSerialPort();
  if (stringComplete) {
    stringComplete = false;
    if (inputString.indexOf("go") >= 0) {
      Serial.println("go");
      modulationState = true;
      lastLEDUpdateTime = micros();
      modulationStartTime = micros();
    }
    if (inputString.indexOf("stop") >= 0) {
      setToBackground();
      Serial.println("stop");
      modulationState = false;
    }
    if (inputString.indexOf("blink") >= 0) {
      Serial.println("stop");
      setToOff();
      delay(int(blinkDurationSecs * 1000));
      setToBackground();
    }
    if (inputString.indexOf("off") >= 0) {
      setToOff();
      Serial.println("off");
      modulationState = false;
    }
    if (inputString.indexOf("background") >= 0) {
      setToBackground();
      Serial.println("background");
      modulationState = false;
    }
    if (inputString.indexOf("config") >= 0) {
      Serial.println("== config mode");
      modulationState = false;
      configMode = true;
    }
    inputString = "";
  }

  // Advance the LED settings
  if (modulationState) {
    unsigned long currentTime = micros();
    if ((currentTime - lastLEDUpdateTime) > minLEDAddressTime) {
      // Determine where we are in the cycle
      unsigned long cycleTime = ((currentTime - modulationStartTime) % cycleDur);
      double cyclePhase = double(cycleTime) / double(cycleDur);
      // update the lastTime
      lastLEDUpdateTime = currentTime;
      // send the newLED settings
      updateLED(cyclePhase, cycleLED);
      // advance the cycleLED
      cycleLED++;
      cycleLED = cycleLED % nLEDs;
    }
  }
}

void getConfig() {
  waitForNewString();
  stringComplete = false;
  if (inputString.indexOf("run") >= 0) {
    Serial.println("== run mode");
    configMode = false;
    modulationState = false;
  }
  if (inputString.indexOf("waveform") >= 0) {
    inputString = "";
    Serial.print("waveform index: ");
    waitForNewString();
    waveform = inputString.toInt();
    if (waveform == 0) Serial.println("step");
    if (waveform == 1) Serial.println("sin");
    if (waveform == 2) Serial.println("square");
    if (waveform == 3) Serial.println("saw on");
    if (waveform == 4) Serial.println("saw off");
  }
  if (inputString.indexOf("freq") >= 0) {
    inputString = "";
    Serial.print("frequency in Hz: ");
    waitForNewString();
    Serial.print(inputString);
    cycleDur = 1e6 / inputString.toFloat();
  }
  if (inputString.indexOf("ampModType") >= 0) {
    inputString = "";
    Serial.print("Amplitude modulation type: ");
    waitForNewString();
    ampModType = inputString.toInt();
    if (ampModType == 0) Serial.println("none");
    if (ampModType == 1) Serial.println("half cosine window");
    if (ampModType == 2) Serial.println("sin amplitude modulate");
  }
  if (inputString.indexOf("led") >= 0) {
    String ledString = inputString.substring(inputString.length() - 2);
    inputString = "";
    int ledIndex = ledString.toInt();
    Serial.print("Settings for LED");
    Serial.print(ledIndex);
    Serial.print(":");
    waitForNewString();
    updateSettingsMatrix(settings, ledIndex, inputString);
    identifyActiveLEDs();
  }
  if (inputString.indexOf("print") >= 0) {
    printCurrentSettings();
  }
  inputString = "";
}

void pollSerialPort() {
  while (Serial.available()) {
    // get the new byte:
    char inChar = (char)Serial.read();
    // add it to the inputString:
    inputString += inChar;
    // if the incoming character is a newline,
    // set a flag so the main loop can
    // do something about it:
    if (inChar == '\n') {
      stringComplete = true;
    }
  }
}

void waitForNewString() {
  bool stillWaiting = true;
  while (stillWaiting) {
    while (Serial.available()) {
      // get the new byte:
      char inChar = (char)Serial.read();
      // add it to the inputString:
      inputString += inChar;
      // if the incoming character is a newline, set a flag so the main loop can
      // do something about it:
      if (inChar == '\n') {
        stringComplete = true;
        stillWaiting = false;
      }
    }
  }
}

void identifyActiveLEDs() {
  // Identify those LEDs that never differ from the background and
  // remove them from the active list
  int nActiveLEDs = 0;
  for (int ii = 0; ii < nLEDs; ii++) {
    int levelIdx = 0;
    bool anyDiff = false;
    bool stillChecking = true;
    while (stillChecking) {
      if (settings[ii][levelIdx] != background[ii]) {
        anyDiff = true;
        stillChecking = false;
      } else {
        levelIdx++;
        if (levelIdx == nLevels) {
          stillChecking = false;
        }
      }
    }
    if (anyDiff) {
      ledIsActive[ii] = true;
      nActiveLEDs++;
    } else {
      ledIsActive[ii] = false;
    }
  }
}

int updateSettingsMatrix(int settings[nLEDs][nLevels], int selectedRow, String inputString) {
  // This function updates settings matrix by accepting a string, converting it to array and
  // appending to settingsMatrix
  inputString += ',';        // Add a comma at the end of the input string to make life easier
  String vectorString = "";  // Set a vector string which will be appended with chars
  int numberOfCommas = -1;   // Comma counter, zero indexed language, so start from -1
  // Loop through input string. if not comma, append to vectorString
  // If comma, assign the completed vectorString to a vector index.
  for (int i = 0; i < inputString.length(); i++) {
    char c = inputString[i];
    if (c != ',') {
      vectorString += c;
    } else {
      numberOfCommas += 1;
      settings[selectedRow][numberOfCommas] = vectorString.toInt();
      vectorString = "";
    }
  }
  return settings[nLEDs][nLevels];
}

void setToBackground() {
  if (simulatePrizmatix) {
    // Use the built in arduino LED, which has a binary state
    int ii = 0;
    int ledSetting = settings[ii][background[ii]];
    if (ledSetting > (maxVal / 2)) {
      digitalWrite(LED_BUILTIN, HIGH);
    } else {
      digitalWrite(LED_BUILTIN, LOW);
    }
  } else {
    for (int ii = 0; ii < nLEDs; ii++) {
      // Get the setting for this LED
      int ledSetting = settings[ii][background[ii]];
      writeToOneCombiLED(ledSetting, ii);
    }
  }
}

void setToOff() {
  if (simulatePrizmatix) {
    // Use the built in arduino LED, which has a binary state
    digitalWrite(LED_BUILTIN, LOW);
  } else {
    for (int ii = 0; ii < nLEDs; ii++) {
      // Get the setting for this LED
      writeToOneCombiLED(0, ii);
    }
  }
}

void updateLED(double cyclePhase, int ledIndex) {
  if (ledIsActive[ledIndex]) {
    // Get the level for this LED, based upon waveform
    float floatLevel = getFrequencyModulation(cyclePhase);
    floatLevel = applyAmplitudeModulation(floatLevel, ledIndex);
    int ledLevel = (nLevels - 1) * floatLevel;
    int ledSetting = settings[ledIndex][ledLevel];
    if (simulatePrizmatix) {
      pulseWidthModulate(ledSetting);
    } else {
      writeToOneCombiLED(ledSetting, ledIndex);
    }
  }
}

float getFrequencyModulation(float phase) {
  // Provides the "level", between 0-1, of a
  // temporal modulation
  float level = 0.5;
  if (waveform == 1) {  // sin
    level = ((sin(2 * pi * phase) + 1) / 2);
  }
  if (waveform == 2) {  // square wave
    if (phase >= 0.5) {
      level = 1;
    } else {
      level = 0;
    }
  }
  if (waveform == 3) {  // saw on
    level = phase;
  }
  if (waveform == 4) {  // saw off
    level = 1 - phase;
  }
  if (waveform == 5) {  // Stockman example A
    float minMax[] = { -0.8532, 1.4950 };
    float harmFreqs[] = { 1, 2 };
    float harmAmps[] = { 1, 0.5 };
    float harmPhases[] = { 0, 256 / 360 };
    level = 0;
    for (int ii = 1; ii < 2; ii++) {
      level = level + harmAmps[ii] * sin(2 * pi * phase * harmFreqs[ii] + 2 * pi * harmPhases[ii] * harmFreqs[ii]);
    }
    level = (level - minMax[0]) / (minMax[1] - minMax[0]);
  }
  // ensure that level is within the 0-1 range
  level = max(level, 0);
  level = min(level, 1);
  return level;
}

float applyAmplitudeModulation(float level, int ledIndex) {
  if (ampModType == 1) {  // Half-cosine window at block onset and offset
    float totalDur = 1 / ampVals[ampModType][0];
    float rampDur = ampVals[ampModType][1];
    // Determine how far along the half-cosine ramp we are, relative
    // to the modulation frequency given by ampVals[0]
    double elapsedTimeSecs = fmod((micros() - modulationStartTime) / 1e6, totalDur);
    float modLevel = 0;
    float blockOnDur = totalDur / 2;
    float plateauDur = blockOnDur - rampDur;
    if (elapsedTimeSecs < rampDur) {
      modLevel = (cos(pi + pi * (elapsedTimeSecs / rampDur)) + 1) / 2;
    }
    if ((elapsedTimeSecs > rampDur) && (elapsedTimeSecs < plateauDur)) {
      modLevel = 1.0;
    }
    if ((elapsedTimeSecs > plateauDur) && (elapsedTimeSecs < blockOnDur)) {
      modLevel = (cos(pi * ((elapsedTimeSecs - plateauDur) / rampDur)) + 1) / 2;
    }
    // center the level around the background
    float offset = float(settings[ledIndex][background[ledIndex]]) / float(maxVal);
    level = (level - offset) * modLevel + offset;
  }
  if (ampModType == 2) {
    float AMFrequencyHz = ampVals[ampModType][0];
    float AMDepth = ampVals[ampModType][1];
    // Determine how far along the modulation we are
    float elapsedTimeSecs = (micros() - modulationStartTime) / 1e6;
    float modLevel = AMDepth * (sin(2 * pi * (elapsedTimeSecs / (1 / AMFrequencyHz))) + 1) / 2;
    // center the level around the background
    float offset = float(settings[ledIndex][background[ledIndex]]) / float(maxVal);
    level = (level - offset) * modLevel + offset;
  }
  return level;
}

void pulseWidthModulate(int setting) {
  // Use pulse-width modulation to vary the
  // intensity of the built in arduino LED
  float portionOn = float(setting) / float(maxVal);
  int timeOn = minLEDAddressTime * portionOn;
  int timeOff = minLEDAddressTime - timeOn;
  unsigned long startTime = micros();
  unsigned long currTime = micros();
  digitalWrite(LED_BUILTIN, HIGH);
  bool notDone = true;
  while (notDone) {
    currTime = micros();
    if ((currTime - startTime) > timeOn) {
      notDone = false;
    }
  }
  startTime = micros();
  digitalWrite(LED_BUILTIN, LOW);
  notDone = true;
  while (notDone) {
    currTime = micros();
    if ((currTime - startTime) > timeOff) {
      notDone = false;
    }
  }
}


void writeToOneCombiLED(int level, int ledIndex) {
  Wire.beginTransmission(0x70);
  Wire.write(1 << ledIndex);
  Wire.endTransmission();
  Wire.beginTransmission(0x61);
  Wire.write(0b01011000);
  Wire.write((uint8_t)(highByte(level << 4)));
  Wire.write((uint8_t)(lowByte(level << 4)));
  Wire.endTransmission(1);
}

void printCurrentSettings() {
  int numRows = sizeof(settings) / sizeof(settings[0]);
  int numCols = sizeof(settings[0]) / sizeof(settings[0][0]);
  for (int r = 0; r < numRows; r++) {
    Serial.print("\n");
    for (int c = 0; c < numCols; c++) {
      Serial.print(settings[r][c]);
      Serial.print(" ");
    }
  }
  Serial.print("\n");
}
