////////////////////////////////////////////////////////////////////////////////
// Firmware for the Prizmatix CombiLED light engine
//
// This code supports the presentation of temporal modulations of the
// spectral content of light generated by the CombiLED device. The device
// contains 8, narrow-band LEDs under the control of an Arduino Uno.
//
// The LEDs have the following spectroradiometric properties:
//            peak (nm)    FWHM (nm)     power (mW_)
//  LED0 --   405          14            1900
//  LED1 --   424          27            750
//  LED2 --   470          21            460
//  LED3 --   498          22            295
//  LED4 --   540          67            680
//  LED5 --   598          14            88
//  LED6 --   627          19            480
//  LED7 --   561          15            470
//
// A "settings" matrix specifies the intensity level of each LED between
// 0 and 1 with 1e-4 precision. An ordered set of 51 discrete levels are
// provided for each primary. These levels might define a linear change in
// luminance or Lâ€“M contrast, for example. Gamma correction is performed on
// device, and the resulting floating level is then cast into a 12 bit
// LED setting
//
// Over time, we present a given column of the settings by assigning the
// values to the LEDs. The particular column that is presented is under the
// control of a waveform (e.g., sin, square) and a frequency [Hz]. After
// setup, the code enters a run loop during which each LED is updated
// sequentially. The waveform is used to define a floating point level (0-1),
// which is mapped to the discrete levels (0-51). The settings matrix provides
// the setting of a given LED at the given level.
//
// There is a minimum amount of time required to address an LED (about 250
// microseconds). The program clock advances and, at this interval, determines
// where we are in the waveform cycle and updates the next LED to the setting
// for that LED. As a consequence, different LEDs oscillate at different phase
// delays of the waveform. As the waveform frequency is unlikely to be
// synchronized to the minimum LED refresh rate, this phase delay will precess
// across waveform cycles. This can cause aliasing of the modulation to lower
// frequencies. To ameliorate this, the LEDs are updated in an interleaved order.
//
// If an LED has settings that never vary from the background, then that LED
// is marked as "inactive", and skipped in the sequential updating. This allows
// the remaining, active LEDs to be updated more frequently.
//
// In addition to the frequency modulation of the waveform, a superimposed
// amplitude modulation may be specified.
//
// In operation, the firmware supports placing the device in three states:
//  RUN MODE (RM) -- continuously present the specified modulation
//  CONFIG MODE (CM) -- change the parameters of the modulation
//  DIRECT MODE (DM) -- pass setting values directly to the LEDs; this
//                      mode is used when performing device calibration.
//
// Global variables of note:
//  simulatePrizmatix   Boolean. If set to true, the code treats the Arduino
//                      built-in LED as LED0. The intensity of the LED is
//                      pulse-width modulated. The other 7 channels are ignored.
//  maxLevelVal         4095. This is the max of the 12-bit range.
//  minLEDAddressTime   Scalar, microseconds. We find that it takes 234 microsecs
//                      to write a setting to one LED. We set this minimum address
//                      time to somewhat longer than this to allow time for
//                      computation overhead.
//  settings            8x51 int matrix, all between 0 and 1e4. Each column
//                      defines the linear settings on the 8 LEDs at each of n
//                      levels of the modulation. The specified value is divided
//                      by 1e4 to yield a value between 0 and 1. This value is
//                      subject to gamma correction prior to being passed to the
//                      LED.
//  background          8x1 int array of value 0-1e4. Specifies the
//                      background level for each LED.
//  contrast            Float, between 0 and 1. Defines the contrast of the
//                      modulation relative to its maximum.
//  gammaParams         8x6 float matrix. Defines the parameters of a 5th order
//                      polynomial (plus an offset) that define the conversion
//                      of the desired intensity level to the corresponding
//                      device level for each LED.
//  waveformIndex       Scalar. Defines the waveform profile to be used:
//                        0 - no modulation (stay at background)
//                        1 - sinusoid
//                        2 - square wave (off-on)
//                        3 - saw-tooth on
//                        4 - saw-tooth off
//                        5 - compound modulation
//  cycleDur            Scalar. The duration in microseconds of the waveform.
//  phaseOffset         Float, 0-2pi. Used to shift the phase of the waveform.
//  amplitudeIndex      Scalar. Defines the amplitude modulation profile:
//                        0 - none
//                        1 - sinusoid modulation
//                        2 - half-cosine window
//  amplitudeVals       2x1 float array. Values control the amplitude modulation,
//                      varying by the amplitudeIndex:
//                        0 - [unused, unused]
//                        1 - [frequency Hz, modulation depth 0-1]
//                        2 - [block frequency (on then off), half-cosine duration]
//  blinkDurationMSecs  Scalar. Duration of attention event in milliseconds.
//                      During run-mode, passing a "blink" command sets all LEDs
//                      to zero for the blink duration. Default is 100 msecs.
//  ledUpdateOrder      8x1 int array, of values 0-7. Defines the order in which
//                      the LEDs are updated across the cycle. By default, the order
//                      interleaves LEDs.
//
//
//

// package to write to the LEDs
#include <Wire.h>


///////////////////// SIMULATE PRIZMATIX /////////////////////////////
// Set this variable to use the built-in LED to simulate
// the output of the Prizmatix device
//
bool simulatePrizmatix = false;
/////////////////////////////////////////////////////////////////////

// Fixed hardware values
const int maxLevelVal = 4095;       // maximum setting value for the prizmatix LEDs
const int minLEDAddressTime = 300;  // the time, in microseconds, required to send an LED setting

// Fixed reality values
const float pi = 3.1415927;

// Fixed value that scales the settings and background values to floats between 0 and 1
const int settingScale = 1e4;

// Define the device states
enum { CONFIG,
       RUN,
       DIRECT } deviceState = RUN;

// Global and control variables
const uint8_t inputStringLen = 12;  // size of the string buffer used to send commands
char inputString[inputStringLen];   // a character vector to hold incoming data
uint8_t inputCharIndex = 0;         // index to count our accumulated characters
bool stringComplete = false;        // whether the input string is complete
bool modulationState = false;       // When we are running, are we modulating?

// Define settings and modulations
const uint8_t nLEDs = 8;     // the number of LEDs
const uint8_t nLevels = 51;  // the number of discrete settings that are specified for each LED

// Define a set of gamma functions. Each gamma function is a 5th order polynomial (plus a
// constant) that maps an input setting to an output setting
const int nGammaParams = 6;
float gammaParams[nLEDs][nGammaParams] = {
  { 0.3241, -0.9178, 0.9954, -0.8699, 1.4695, -0.0033 },
  { 3.4026, -9.9485, 11.0843, -6.1732, 2.6318, 0.0054 },
  { -4.6673, 12.4840, -11.6360, 3.6100, 1.2128, -0.0077 },
  { 2.0584, -5.7416, 6.2709, -3.9664, 2.3784, 0.0012 },
  { 1.5879, -4.5637, 4.9856, -2.8691, 1.8582, 0.0017 },
  { 2.0232, -5.3562, 4.9171, -2.1851, 1.5988, 0.0041 },
  { 0.6844, -1.9140, 1.6533, -0.8179, 1.3934, -0.0008 },
  { 1.3413, -3.8755, 4.0251, -1.8342, 1.3422, 0.0016 },
};

// Light Flux, ~100 % contrast
int settings[nLEDs][nLevels] = {
  { 0, 200, 400, 600, 800, 1000, 1200, 1400, 1600, 1800, 2000, 2200, 2400, 2600, 2800, 3000, 3200, 3400, 3600, 3800, 4000, 4200, 4400, 4600, 4800, 5000, 5200, 5400, 5600, 5800, 6000, 6200, 6400, 6600, 6800, 7000, 7200, 7400, 7600, 7800, 8000, 8200, 8400, 8600, 8800, 9000, 9200, 9400, 9600, 9800, 10000 },
  { 0, 200, 400, 600, 800, 1000, 1200, 1400, 1600, 1800, 2000, 2200, 2400, 2600, 2800, 3000, 3200, 3400, 3600, 3800, 4000, 4200, 4400, 4600, 4800, 5000, 5200, 5400, 5600, 5800, 6000, 6200, 6400, 6600, 6800, 7000, 7200, 7400, 7600, 7800, 8000, 8200, 8400, 8600, 8800, 9000, 9200, 9400, 9600, 9800, 10000 },
  { 0, 200, 400, 600, 800, 1000, 1200, 1400, 1600, 1800, 2000, 2200, 2400, 2600, 2800, 3000, 3200, 3400, 3600, 3800, 4000, 4200, 4400, 4600, 4800, 5000, 5200, 5400, 5600, 5800, 6000, 6200, 6400, 6600, 6800, 7000, 7200, 7400, 7600, 7800, 8000, 8200, 8400, 8600, 8800, 9000, 9200, 9400, 9600, 9800, 10000 },
  { 0, 200, 400, 600, 800, 1000, 1200, 1400, 1600, 1800, 2000, 2200, 2400, 2600, 2800, 3000, 3200, 3400, 3600, 3800, 4000, 4200, 4400, 4600, 4800, 5000, 5200, 5400, 5600, 5800, 6000, 6200, 6400, 6600, 6800, 7000, 7200, 7400, 7600, 7800, 8000, 8200, 8400, 8600, 8800, 9000, 9200, 9400, 9600, 9800, 10000 },
  { 0, 200, 400, 600, 800, 1000, 1200, 1400, 1600, 1800, 2000, 2200, 2400, 2600, 2800, 3000, 3200, 3400, 3600, 3800, 4000, 4200, 4400, 4600, 4800, 5000, 5200, 5400, 5600, 5800, 6000, 6200, 6400, 6600, 6800, 7000, 7200, 7400, 7600, 7800, 8000, 8200, 8400, 8600, 8800, 9000, 9200, 9400, 9600, 9800, 10000 },
  { 0, 200, 400, 600, 800, 1000, 1200, 1400, 1600, 1800, 2000, 2200, 2400, 2600, 2800, 3000, 3200, 3400, 3600, 3800, 4000, 4200, 4400, 4600, 4800, 5000, 5200, 5400, 5600, 5800, 6000, 6200, 6400, 6600, 6800, 7000, 7200, 7400, 7600, 7800, 8000, 8200, 8400, 8600, 8800, 9000, 9200, 9400, 9600, 9800, 10000 },
  { 0, 200, 400, 600, 800, 1000, 1200, 1400, 1600, 1800, 2000, 2200, 2400, 2600, 2800, 3000, 3200, 3400, 3600, 3800, 4000, 4200, 4400, 4600, 4800, 5000, 5200, 5400, 5600, 5800, 6000, 6200, 6400, 6600, 6800, 7000, 7200, 7400, 7600, 7800, 8000, 8200, 8400, 8600, 8800, 9000, 9200, 9400, 9600, 9800, 10000 },
  { 0, 200, 400, 600, 800, 1000, 1200, 1400, 1600, 1800, 2000, 2200, 2400, 2600, 2800, 3000, 3200, 3400, 3600, 3800, 4000, 4200, 4400, 4600, 4800, 5000, 5200, 5400, 5600, 5800, 6000, 6200, 6400, 6600, 6800, 7000, 7200, 7400, 7600, 7800, 8000, 8200, 8400, 8600, 8800, 9000, 9200, 9400, 9600, 9800, 10000 },
};
uint8_t background[nLEDs] = { 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000 };

// Adjust the overall contrast of the modulation between 0 and 1
float contrast = 1;

// The ledIsActive vector is regenerated whenever the settings or background
// changes. The idea is to skip updating LEDs if their settings never change
// from the background. Set to false initially, but we will check and update
// this before entering the loop.
bool ledIsActive[nLEDs] = { false, false, false, false, false, false, false, false };

// Variables that define an amplitude modulation
uint8_t amplitudeIndex = 0;  // Default to no amplitude modulation
float amplitudeVals[3][2] = {
  { 0.0, 0.0 },  // unused entries for no amplitude modulation
  { 0.1, 1.0 },  // AM modulation: frequency Hz, AM depth
  { 0.1, 1.5 },  // Half-cosine window: block frequency Hz, window duration seconds
};

// Variables the define compound modulations. Support is provided for a compound modulation
// composed of up to 5 sinusoids. For each sinusoid, we specify the harmonic index relative
// to the fundamental FM modulation frequency (0 for no modulation), the relative amplitude
// of that harmonic component, and the relative phase (in radians). Finally, we need to know
// the min and max values across a full cycle of a given compound waveform. The compoundRange
// variable holds the result. See the function "updateCompoundRange" for details.
float compoundHarmonics[5] = { 1, 2, 4, 0, 0 };         // Multiples of the fundamental
float compoundAmps[5] = { 0.5, 1, 1, 0, 0 };            // Relative amplitudes
float compoundPhases[5] = { 0, 0.7854, 4.3633, 0, 0 };  // Phase delay in radians
float compoundRange[2] = { 0, 1 };

// Timing variables
uint8_t waveformIndex = 1;                              // Default to sinusoid
unsigned long cycleDur = round(1e6 / 3.0);              // Initialize at 3 Hz
unsigned long modulationStartTime = micros();           // Initialize these with the clock
unsigned long lastLEDUpdateTime = micros();             // Initialize these with the clock
int blinkDurationMSecs = 100;                           // Default duration of the blink event in msecs
uint8_t ledCycleIdx = 0;                                // Counter to index our cycle through updating LEDs
float phaseOffset = 0;                                  // 0-2pi, used to shift the waveform phase
uint8_t ledUpdateOrder[] = { 0, 2, 4, 6, 1, 3, 5, 7 };  // The order in which LEDs are updated
float modulationDurSecs = 0;                            // Duration of the modulation in secs (0 for continuous)
int long cycleCount = 0;                                // Num cycles elapsed since modulation start


// setup
void setup() {
  // Initialize serial port communication
  Serial.begin(57600);
  // Modify the settings and background if we are simulating
  if (simulatePrizmatix) {
    for (int ii = 1; ii < nLEDs; ii++) {
      for (int jj = 0; jj < nLevels; jj++) {
        settings[ii][jj] = 0;
      }
      background[ii] = 0;
    }
  }
  // Initialize communication with the LED(s)
  if (simulatePrizmatix) {
    // Use the built-in LED
    pinMode(LED_BUILTIN, OUTPUT);
  } else {
    // USe the wired LEDs
    Wire.begin();
    Wire.setClock(400000);
  }
  // Check which LEDs are "active"
  identifyActiveLEDs();
  // Set the device to background
  setToBackground();
  // Update the compoundRange, in case we have
  // a compound modulation to start
  updateCompoundRange();
  // Show the console menu
  showModeMenu();
}

// loop
void loop() {
  // Handle inputs dependent upon the deviceState
  switch (deviceState) {
    case CONFIG:
      getConfig();
      break;
    case DIRECT:
      getDirect();
      break;
    case RUN:
      getRun();
      break;
  }
  // Advance the LED settings
  if (modulationState) {
    unsigned long currentTime = micros();
    if ((currentTime - lastLEDUpdateTime) > minLEDAddressTime) {
      // Determine where we are in the cycle
      unsigned long cycleTime = ((currentTime - modulationStartTime) % cycleDur);
      double cyclePhase = double(cycleTime) / double(cycleDur);
      // Update the lastTime
      lastLEDUpdateTime = currentTime;
      // Update the next LED
      updateLED(cyclePhase, ledUpdateOrder[ledCycleIdx]);
      // Advance the ledCycleIdx
      ledCycleIdx++;
      ledCycleIdx = ledCycleIdx % nLEDs;
    }
    // Check if we have exceeded the modulation duration
    if (modulationDurSecs > 0) {
      float elapsedTimeSecs = (currentTime - modulationStartTime) / 1e6;
      if (elapsedTimeSecs > modulationDurSecs) {
        modulationState = false;
        setToBackground();
      }
    }
  }
}

// Had to comment out the menu details as these serial entries
// eat up dynamic memory space.
void showModeMenu() {
  switch (deviceState) {
    case CONFIG:
      Serial.println("CM");
      // Serial.println("WF: waveform index, FQ: FM freq [Hz]");
      // Serial.println("AM: AM index, V0...Vn: AM vals idx n");
      // Serial.println("L0, L1, .., Ln: Settings for LED n");
      // Serial.println("PR: print current settings matrix");
      // Serial.println("RM: run mode, DM: direct mode");
      break;
    case DIRECT:
      Serial.println("DM");
      // Serial.println("LL: settings [0 4095] for LEDs 0-7");
      // Serial.println("RM: run mode, CM: config mode");
      break;
    case RUN:
      Serial.println("RM");
      // Serial.println("GO: go, SP: stop, BL: blink");
      // Serial.println("BG: background, DK: all off");
      // Serial.println("CM: config mode, DM: direct mode");
      break;
  }
}

void getConfig() {
  // Operate in modal state waiting for input
  waitForNewString();
  if (strncmp(inputString, "WF", 2) == 0) {
    // waveformIndex controls the FM modulation form
    Serial.println("WF:");
    clearInputString();
    waitForNewString();
    waveformIndex = atoi(inputString);
    if (waveformIndex == 0) Serial.println("none");
    if (waveformIndex == 1) Serial.println("sin");
    if (waveformIndex == 2) Serial.println("square");
    if (waveformIndex == 3) Serial.println("sawon");
    if (waveformIndex == 4) Serial.println("sawoff");
    if (waveformIndex == 5) {
      Serial.println("compound");
      updateCompoundRange();
    }
  }
  if (strncmp(inputString, "FQ", 2) == 0) {
    // Carrier modulation frequency (float Hz)
    Serial.println("FQ:");
    clearInputString();
    waitForNewString();
    cycleDur = 1e6 / atof(inputString);
    Serial.println(atof(inputString));
  }
  if (strncmp(inputString, "MD", 2) == 0) {
    // Modulation duration (float seconds)
    // Set to zero to have the modulation
    // continue until stopped
    Serial.println("MD:");
    clearInputString();
    waitForNewString();
    modulationDurSecs = atof(inputString);
    Serial.println(atof(inputString));
  }
  if (strncmp(inputString, "CN", 2) == 0) {
    // Contrast (0-1 float)
    Serial.println("CN:");
    clearInputString();
    waitForNewString();
    contrast = atof(inputString);
    Serial.println(atof(inputString));
  }
  if (strncmp(inputString, "PH", 2) == 0) {
    // Phase offset (0-2pi float)
    Serial.println("PH:");
    clearInputString();
    waitForNewString();
    phaseOffset = atof(inputString);
    Serial.println(atof(inputString));
  }
  if (strncmp(inputString, "AM", 2) == 0) {
    // Amplitude modulation index
    Serial.println("AM:");
    clearInputString();
    waitForNewString();
    amplitudeIndex = atoi(inputString);
    if (amplitudeIndex == 0) Serial.println("none");
    if (amplitudeIndex == 1) Serial.println("sin");
    if (amplitudeIndex == 2) Serial.println("half-cos");
  }
  if (strncmp(inputString, "AV", 2) == 0) {
    // Amplitude modulation values for the current index
    Serial.println("AV0:");
    clearInputString();
    waitForNewString();
    float newVal = atof(inputString);
    amplitudeVals[amplitudeIndex][0] = newVal;
    Serial.println("AV1:");
    clearInputString();
    waitForNewString();
    newVal = atof(inputString);
    amplitudeVals[amplitudeIndex][1] = newVal;
    Serial.println(".");
  }
  if (strncmp(inputString, "CH", 2) == 0) {
    // Compound modulation, 5 harmonic indices
    Serial.println("CH:");
    clearInputString();
    for (int ii = 0; ii < 5; ii++) {
      waitForNewString();
      float newVal = atof(inputString);
      compoundHarmonics[ii] = newVal;
      Serial.println(".");
      clearInputString();
    }
    updateCompoundRange();
  }
  if (strncmp(inputString, "CA", 2) == 0) {
    // Compound modulation, 5 harmonic amplitudes
    Serial.println("CA:");
    clearInputString();
    for (int ii = 0; ii < 5; ii++) {
      waitForNewString();
      float newVal = atof(inputString);
      compoundAmps[ii] = newVal;
      Serial.println(".");
      clearInputString();
    }
    updateCompoundRange();
  }
  if (strncmp(inputString, "CP", 2) == 0) {
    // Compound modulation, 5 harmonic phases
    Serial.println("CP:");
    clearInputString();
    for (int ii = 0; ii < 5; ii++) {
      waitForNewString();
      float newVal = atof(inputString);
      compoundPhases[ii] = newVal;
      Serial.println(".");
      clearInputString();
    }
    updateCompoundRange();
  }
  if (strncmp(inputString, "ST", 2) == 0) {
    // Matrix of settings int, 0-1e4
    Serial.print("ST:");
    clearInputString();
    for (int ii = 0; ii < nLEDs; ii++) {
      for (int jj = 0; jj < nLevels; jj++) {
        waitForNewString();
        int level = atoi(inputString);
        settings[ii][jj] = level;
        Serial.println(".");
        clearInputString();
      }
    }
    identifyActiveLEDs();
  }
  if (strncmp(inputString, "GP", 2) == 0) {
    // Matrix of gamma parameters (float)
    Serial.print("GP:");
    clearInputString();
    for (int ii = 0; ii < nLEDs; ii++) {
      for (int jj = 0; jj < nGammaParams; jj++) {
        waitForNewString();
        gammaParams[ii][jj] = atof(inputString);
        Serial.println(".");
        clearInputString();
      }
    }
    identifyActiveLEDs();
  }
  if (strncmp(inputString, "BG", 2) == 0) {
    // Matrix of background settings int, 0-1e4
    Serial.print("BG:");
    clearInputString();
    for (int ii = 0; ii < nLEDs; ii++) {
      waitForNewString();
      int level = atoi(inputString);
      background[ii] = level;
      Serial.println(".");
      clearInputString();
    }
    identifyActiveLEDs();
    setToBackground();
  }
  if (strncmp(inputString, "PR", 2) == 0) {
    // Print current settings
    printCurrentSettings();
  }
  if (strncmp(inputString, "RM", 2) == 0) {
    // Switch to run mode
    modulationState = false;
    deviceState = RUN;
    setToBackground();
    showModeMenu();
  }
  if (strncmp(inputString, "DM", 2) == 0) {
    // Switch to direct control mode
    modulationState = false;
    deviceState = DIRECT;
    showModeMenu();
  }
  clearInputString();
}

void getDirect() {
  // Operate in modal state waiting for input
  waitForNewString();

  // The primary Direct mode activity: send a
  // vector of settings for the LEDs.
  if (strncmp(inputString, "LL", 2) == 0) {
    Serial.println("LL:");
    clearInputString();
    for (int ii = 0; ii < nLEDs; ii++) {
      waitForNewString();
      int level = atoi(inputString);
      Serial.println(".");
      clearInputString();
      if (simulatePrizmatix) {
        pulseWidthModulate(level);
      } else {
        writeToOneCombiLED(level, ii);
      }
    }
    Serial.println(".");
  }
  if (strncmp(inputString, "DK", 2) == 0) {
    setToOff();
    Serial.println(".");
    modulationState = false;
  }
  if (strncmp(inputString, "RM", 2) == 0) {
    modulationState = false;
    deviceState = RUN;
    setToBackground();
    showModeMenu();
  }
  if (strncmp(inputString, "CM", 2) == 0) {
    modulationState = false;
    deviceState = CONFIG;
    showModeMenu();
  }
  clearInputString();
}

void getRun() {
  // Operate in amodal state; only act if we have
  // a complete string
  pollSerialPort();
  if (stringComplete) {
    stringComplete = false;
    if (strncmp(inputString, "GO", 2) == 0) {
      Serial.println(".");
      modulationState = true;
      lastLEDUpdateTime = micros();
      modulationStartTime = micros();
    }
    if (strncmp(inputString, "SP", 2) == 0) {
      setToBackground();
      Serial.println(".");
      modulationState = false;
    }
    if (strncmp(inputString, "BL", 2) == 0) {
      Serial.println(".");
      setToOff();
      delay(blinkDurationMSecs);
      setToBackground();
    }
    if (strncmp(inputString, "BG", 2) == 0) {
      setToBackground();
      Serial.println(".");
      modulationState = false;
    }
    if (strncmp(inputString, "DK", 2) == 0) {
      setToOff();
      Serial.println(".");
      modulationState = false;
    }
    if (strncmp(inputString, "DM", 2) == 0) {
      modulationState = false;
      setToBackground();
      deviceState = DIRECT;
      showModeMenu();
    }
    if (strncmp(inputString, "CM", 2) == 0) {
      modulationState = false;
      setToBackground();
      deviceState = CONFIG;
      showModeMenu();
    }
    clearInputString();
  }
}

void pollSerialPort() {
  // Detect the case that we have received a complete string but
  // have not yet finished doing something with it. In this case,
  // do not accept anything further from the buffer
  if ((stringComplete) && (inputCharIndex == 0)) return;
  // See if there is something in the buffer
  while (Serial.available()) {
    // get the new byte:
    char inChar = (char)Serial.read();
    // add it to the inputString:
    inputString[inputCharIndex] = inChar;
    inputCharIndex++;
    if (inputCharIndex >= inputStringLen) {
      Serial.println("ERROR: Input overflow inputString buffer");
      clearInputString();
      return;
    }
    // if the incoming character is a newline,
    // set a flag so the main loop can
    // do something about it.
    if (inChar == '\n') {
      stringComplete = true;
      inputCharIndex = 0;
    }
  }
}

void waitForNewString() {
  bool stillWaiting = true;
  while (!stringComplete) {
    pollSerialPort();
  }
}

void updateCompoundRange() {
  // Handle compound modulations. We need
  // to scale the waveform between 0 and 1. Here we examine
  // waveform across an entire cycle and store the range to be
  // used later to scale the levels to within 0 and 1.
  if (waveformIndex < 5) return;
  compoundRange[0] = 0;
  compoundRange[1] = 1;
  float newRange[2] = { 0, 0 };
  float phase = 0;
  float level = 0;
  for (int ii = 0; ii < 1000; ii++) {
    phase = float(ii) / 1000;
    level = getFrequencyModulation(phase);
    newRange[0] = min(newRange[0], level);
    newRange[1] = max(newRange[1], level);
  }
  compoundRange[0] = newRange[0];
  compoundRange[1] = newRange[1];
}

void identifyActiveLEDs() {
  // Identify those LEDs that never differ from the background and
  // remove them from the active list
  int nActiveLEDs = 0;
  for (int ii = 0; ii < nLEDs; ii++) {
    int levelIdx = 0;
    bool anyDiff = false;
    bool stillChecking = true;
    while (stillChecking) {
      if (settings[ii][levelIdx] != background[ii]) {
        anyDiff = true;
        stillChecking = false;
      } else {
        levelIdx++;
        if (levelIdx == nLevels) {
          stillChecking = false;
        }
      }
    }
    if (anyDiff) {
      ledIsActive[ii] = true;
      nActiveLEDs++;
    } else {
      ledIsActive[ii] = false;
    }
  }
}

void setToBackground() {
  if (simulatePrizmatix) {
    // Use the built in arduino LED, which has a binary state
    int ii = 0;
    int ledSetting = settings[ii][background[ii]];
    if (ledSetting > (maxLevelVal / 2)) {
      digitalWrite(LED_BUILTIN, HIGH);
    } else {
      digitalWrite(LED_BUILTIN, LOW);
    }
  } else {
    for (int ii = 0; ii < nLEDs; ii++) {
      // Get the setting for this LED
      int ledSetting = settings[ii][background[ii]];
      writeToOneCombiLED(ledSetting, ii);
    }
  }
}

void setToOff() {
  if (simulatePrizmatix) {
    // Use the built in Arduino LED, which has a binary state
    digitalWrite(LED_BUILTIN, LOW);
  } else {
    // Loop through the LEDs and set them to zero
    for (int ii = 0; ii < nLEDs; ii++) {
      writeToOneCombiLED(0, ii);
    }
  }
}

void updateLED(double cyclePhase, int ledIndex) {
  // Check if the current LED is marked as active
  if (ledIsActive[ledIndex]) {
    // Adjust the cyclePhase for the phaseOffset
    cyclePhase = cyclePhase + (phaseOffset / (2 * pi));
    // Get the level for the current cyclePhase
    float floatLevel = getFrequencyModulation(cyclePhase);
    // Get the background level for this LED
    float offset = background[ledIndex] / settingScale;
    // Scale according to the contrast value
    floatLevel = contrast * (floatLevel - offset) + offset;
    // Apply any amplitude modulation
    floatLevel = applyAmplitudeModulation(floatLevel, offset);
    // Cast the continuous floatLevel to one of the 45 discrete
    // levels.
    int discreteLevel = round((nLevels - 1) * floatLevel);
    // Get the float intensity setting from the settings matrix
    // for this level
    float ledSettingFloat = settings[ledIndex][discreteLevel] / settingScale;
    // gamma correct ledSettingFloat
    ledSettingFloat = gammaCorrect(ledSettingFloat, ledIndex);
    // Convert the ledSettingFloat to a 12 bit integer
    int ledSetting = round(ledSettingFloat / maxLevelVal);
    // Update the LED
    if (simulatePrizmatix) {
      pulseWidthModulate(ledSetting);
    } else {
      writeToOneCombiLED(ledSetting, ledIndex);
    }
  }
}


float getFrequencyModulation(float cyclePhase) {
  // Provides a continuous level, between 0-1, for a given waveform
  // at the specified phase position. We default to a half-on level
  // if not otherwise specified
  float level = 0.5;

  // Sinusoid
  if (waveformIndex == 1) {
    level = ((sin(2 * pi * cyclePhase) + 1) / 2);
  }
  // Square wave, off then on
  if (waveformIndex == 2) {
    if (cyclePhase >= 0.5) {
      level = 1;
    } else {
      level = 0;
    }
  }
  // Saw-tooth, ramping on and then sudden off
  if (waveformIndex == 3) {
    level = cyclePhase;
  }
  // Saw-tooth, ramping off and then sudden on
  if (waveformIndex == 4) {  // saw off
    level = 1 - cyclePhase;
  }
  // Compound modulation
  if (waveformIndex == 5) {
    level = 0;
    for (int ii = 0; ii < 5; ii++) {
      level = level + compoundAmps[ii] * sin(compoundHarmonics[ii] * 2 * pi * cyclePhase + compoundPhases[ii]);
    }
    // Use the pre-computed "compoundRange" to place level in the 0-1 range
    level = (level - compoundRange[0]) / (compoundRange[1] - compoundRange[0]);
  }
  return level;
}

float applyAmplitudeModulation(float level, float offset) {
  // Sinusoid amplitude modulation
  if (amplitudeIndex == 1) {
    float AMFrequencyHz = amplitudeVals[amplitudeIndex][0];
    float AMDepth = amplitudeVals[amplitudeIndex][1];
    // Determine how far along the modulation we are
    float elapsedTimeSecs = (micros() - modulationStartTime) / 1e6;
    float modLevel = AMDepth * (sin(2 * pi * (elapsedTimeSecs / (1 / AMFrequencyHz))) + 1) / 2;
    // center the level around the background
    level = (level - offset) * modLevel + offset;
  }
  // Half-cosine window at block onset and offset
  if (amplitudeIndex == 2) {
    float totalDur = 1 / amplitudeVals[amplitudeIndex][0];
    float rampDur = amplitudeVals[amplitudeIndex][1];
    // Determine how far along the half-cosine ramp we are, relative
    // to the modulation frequency given by amplitudeVals[0]
    double elapsedTimeSecs = fmod((micros() - modulationStartTime) / 1e6, totalDur);
    float modLevel = 0;
    float blockOnDur = totalDur / 2;
    float plateauDur = blockOnDur - rampDur;
    if (elapsedTimeSecs < rampDur) {
      modLevel = (cos(pi + pi * (elapsedTimeSecs / rampDur)) + 1) / 2;
    }
    if ((elapsedTimeSecs > rampDur) && (elapsedTimeSecs < plateauDur)) {
      modLevel = 1.0;
    }
    if ((elapsedTimeSecs > plateauDur) && (elapsedTimeSecs < blockOnDur)) {
      modLevel = (cos(pi * ((elapsedTimeSecs - plateauDur) / rampDur)) + 1) / 2;
    }
    // center the level around the background
    level = (level - offset) * modLevel + offset;
  }
  // ensure that level is within the 0-1 range
  level = max(level, 0);
  level = min(level, 1);
  return level;
}

float gammaCorrect(float ledSettingFloat, int ledIndex) {
  float corrected = 0;
  for (int ii = 0; ii < nGammaParams; ii++) {
    corrected = corrected + gammaParams[ledIndex][ii] * pow(ledSettingFloat, (nGammaParams - 1) - ii);
  }
  return corrected;
}

void pulseWidthModulate(int setting) {
  // Use pulse-width modulation to vary the
  // intensity of the built in Arduino LED
  float portionOn = float(setting) / float(maxLevelVal);
  int timeOn = round(minLEDAddressTime * portionOn);
  int timeOff = minLEDAddressTime - timeOn;
  unsigned long startTime = micros();
  unsigned long currTime = micros();
  digitalWrite(LED_BUILTIN, HIGH);
  bool notDone = true;
  while (notDone) {
    currTime = micros();
    if ((currTime - startTime) > timeOn) {
      notDone = false;
    }
  }
  startTime = micros();
  digitalWrite(LED_BUILTIN, LOW);
  notDone = true;
  while (notDone) {
    currTime = micros();
    if ((currTime - startTime) > timeOff) {
      notDone = false;
    }
  }
}

// Send a setting to an wired LED
void writeToOneCombiLED(int level, int ledIndex) {
  // sanitize the input
  level = max(level, 0);
  level = min(level, maxLevelVal);
  // write the values
  Wire.beginTransmission(0x70);
  Wire.write(1 << ledIndex);
  Wire.endTransmission();
  Wire.beginTransmission(0x61);
  Wire.write(0b01011000);
  Wire.write((uint8_t)(highByte(level << 4)));
  Wire.write((uint8_t)(lowByte(level << 4)));
  Wire.endTransmission(1);
}

// Dump the settings matrix to the console
void printCurrentSettings() {
  int numRows = sizeof(settings) / sizeof(settings[0]);
  int numCols = sizeof(settings[0]) / sizeof(settings[0][0]);
  Serial.println("Settings matrix:");
  for (int r = 0; r < numRows; r++) {
    Serial.print("\n");
    for (int c = 0; c < numCols; c++) {
      Serial.print(settings[r][c]);
      Serial.print(" ");
    }
  }
  Serial.print("\n");
}

// Clean-up after receiving inputString
void clearInputString() {
  for (int ii = 0; ii < inputStringLen; ii++) {
    inputString[ii] = "";
  }
  inputCharIndex = 0;
  stringComplete = false;
}